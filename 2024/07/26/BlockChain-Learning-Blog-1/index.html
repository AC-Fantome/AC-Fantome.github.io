<!DOCTYPE html>
<html lang="zn-Ch">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Fantome">





<title>BlockChain Learning Blog 1 | Fantome&#39;s Blog</title>



    <link rel="icon" href="/project/Deep%20River.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/project/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/project/js/script.js"></script>
    
    <script src="/project/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/project/">Fantome&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/project/archives">Posts</a>
                
                    <a class="menu-item" href="/project/category">Categories</a>
                
                    <a class="menu-item" href="/project/tag">Tags</a>
                
                    <a class="menu-item" href="/project/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/project/">Fantome&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/project/archives">Posts</a>
                
                    <a class="menu-item" href="/project/category">Categories</a>
                
                    <a class="menu-item" href="/project/tag">Tags</a>
                
                    <a class="menu-item" href="/project/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">BlockChain Learning Blog 1</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Fantome</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">July 26, 2024&nbsp;&nbsp;18:28:02</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="题型一"><a href="#题型一" class="headerlink" title="题型一"></a><em><strong>题型一</strong></em></h1><h2 id="1-初识区块链"><a href="#1-初识区块链" class="headerlink" title="1.初识区块链"></a><strong>1.初识区块链</strong></h2><ol>
<li><p><strong>区块链</strong>是基于数字加密货币发展而来的点对点架构的分布式数据系统，具有去中心化、去信任化、不可篡改、不可否认、高度自治、分布共识等特征。在多数情况下，区块链可以被看作是利用区块链技术方案实现完全去中心化的点对点分布式账本系统的方法（包括下文，在未强调的情况下，也是使用该定义）。</p>
<table>
<thead>
<tr>
<th>收集到的对区块链的各种定义</th>
</tr>
</thead>
<tbody><tr>
<td>一个分散的、无信任的、防干扰的、分布式的账本。</td>
</tr>
<tr>
<td>一种新型的软件开发架构，以一种仅附加的形式使用独特的数据结构将数据连接成链，并将哈希函数作为映射数据的工具以保证数据的安全。</td>
</tr>
<tr>
<td>利用加密链式区块结构来验证与存储数据、使用分布式节点共识机制来生成和更新数据，并通过智能合约来编程和操作数据的一种去中心化的基础架构与分布式计算范式。</td>
</tr>
<tr>
<td>一个随着时间序列不断增长的去中心化的分布式数据库，其本质是基于非对称加密算法的分布式账本技术。</td>
</tr>
<tr>
<td>电子货币帐簿系统的一种点对点技术实现，由参与者来维护的，可以在网络系统中没有中心服务器的情况下记录每个比特币交易记录。</td>
</tr>
<tr>
<td>区块链是由一组不可变的分布式数字账本组成，它们负责跟踪交易并将其记录在数字块上，区块链架构中所有节点相对应地服务且不依赖中心网络服务器。</td>
</tr>
<tr>
<td>采用密码学的方法将数据块连接在一起并可以进行可行性交易的分布式数据库技术，具有防篡改、可追溯、多方维护的功能。</td>
</tr>
</tbody></table>
<blockquote>
<p>综上所述，区块链概念可以理解为以非对称加密算法为基础，以改进的默克尔树为数据结构，使用共识机制、点对点网络、智能合约等技术结合而成的一种分布式存储数据库技术。</p>
</blockquote>
<p><strong>区块链目前的发展和应用</strong>方向有如下几种：</p>
<ul>
<li>金融服务领域： 区块链技术在金融服务领域的应用最为广泛，尤其是在数字货币、支付清算、资产管理、智能合约等方面。除了比特币以外，许多其他数字货币和稳定币也在不同程度上推动了金融行业的创新和改革。</li>
<li>供应链管理： 区块链技术可以提高供应链管理的透明度、可追溯性和效率，通过记录产品的来源、生产和分配过程，确保产品的质量和安全，防止假冒伪劣产品的流入。</li>
<li>数字身份管理： 区块链技术可以用于数字身份管理，保护个人身份和隐私信息，并提供更安全、更可信的身份验证和身份认证解决方案。</li>
<li>智能合约： 区块链上的智能合约是一种自动执行的合约代码，可以在无需中间人的情况下执行交易和协议。智能合约已经在各种领域得到了广泛应用，包括金融、房地产、保险、供应链等。智能合约是区块链未来发展的重要方向之一。</li>
<li>医疗保健： 区块链技术可以提高医疗保健数据的安全性、可访问性和可追溯性，促进医疗信息的共享和互操作性，加速医疗创新和疾病治疗。</li>
<li>物联网： 区块链与物联网技术的结合可以实现设备之间的信任和安全通信，为物联网应用提供更安全、更可靠的数据交换和管理平台。</li>
</ul>
<p><strong>区块链的模型框架</strong>:</p>
<ul>
<li><strong>区块链的基本框架</strong>：区块链是由一系列网络节点构建的一种分布式账本技术，区块链数据是以交易形式存储到区块中，然后再由区块构成的一种链式结构，其结构如图所示。（区块链网络中的第一个区块被称为*<u>“创世区块“</u>*，通常由区块链系统的开发者或者创始团队完成）</li>
</ul>
<p><img src="C:\Users\wjx27\AppData\Roaming\Typora\typora-user-images\image-20240318215616813.png" alt="image-20240318215616813"></p>
<ul>
<li><p><strong>区块链的架构分层</strong>：区块链架构自下而上可以分为三层，底部服务层、核心层、应用层，如表格所示。</p>
<table>
<thead>
<tr>
<th align="left">区块链分层</th>
<th align="center">技术</th>
<th align="center">实现功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">应用层</td>
<td align="center">基于区块链API接口、智能合约等技术构建的各种应用程序案例集</td>
<td align="center">聚焦业务逻辑，实现所需的功能程序</td>
</tr>
<tr>
<td align="left">核心层</td>
<td align="center">基于密码学算法、共识算法等技术构建的分布式账本体系</td>
<td align="center">实现共享账本的冗余备份和数据验证，确保账本数据的一致性</td>
</tr>
<tr>
<td align="left">底部服务层</td>
<td align="center">运行区块链所需的硬件设施以及存储、P2P网络服务等软件设施</td>
<td align="center">实现节点通信，确保数据的传输</td>
</tr>
</tbody></table>
</li>
<li><p><strong>区块链的技术套件</strong>：通过将区块链应用的技术、组成结构与实现的功能抽象化，我们能够得到区块链的技术套件，如图所示。</p>
<p><img src="C:\Users\wjx27\AppData\Roaming\Typora\typora-user-images\image-20240318215503871.png" alt="image-20240318215503871"></p>
<p>区块链以分布式点对点架构为基础，存储逻辑、共识机制、数据处理逻辑和非对称加密作为核心技术，构建以所有权逻辑、交易数据、交易确认逻辑、交易安全为实现层功能性特征的具体应用。</p>
</li>
<li><p><strong>区块链的内部结构</strong>：在多数情况下的区块链中，一个区块包含区块头（BlockHeader）和区块体（BlockBody）两部分，区块头中的关键信息包括当前版本号（Version）、前区块哈希值（PreviewsHash）、时间戳（Timestamp）、随机数（Nonce）以及默克尔树（MerkleTree）的哈希值（MerkleHash）等信息。前一个区块存储后一个区块的哈希值，并按生成的时间顺序进行连接，物理上是块与块之间的连接，逻辑上是链上信息的关联，构成了一个外表为链内在是数  据关联的账本形式，如图所示。</p>
<p><img src="C:\Users\wjx27\AppData\Roaming\Typora\typora-user-images\image-20240318224448980.png" alt="image-20240318224448980"></p>
</li>
</ul>
</li>
<li><p>根据读写权限极端情况的分类，区块链可分为四种，如图所示。</p>
<table>
<thead>
<tr>
<th align="center">写入权限    \   读写权限与创建交易权限</th>
<th align="center">所有人</th>
<th align="center">少数可信任节点</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>所有人</strong></td>
<td align="center">公有、无须许可 ①</td>
<td align="center">私有、无须许可 ③</td>
</tr>
<tr>
<td align="center"><strong>少数人</strong></td>
<td align="center">公有、许可 ②</td>
<td align="center">私有、许可 ④</td>
</tr>
</tbody></table>
<p>根据<strong>应用的范围</strong>，区块链可以分为以下几种。</p>
<ul>
<li><strong>公有链</strong>：链①即为公有链，是最常见的区块链类型，对所有人开放，任何人都可以加入网络，参与验证和共识过程。公有链具有去中心化、透明度高、安全性强、不可篡改、抗操纵等优点，但缺乏隐私、成本高、延展性差、灵活性差；适用于需要高度去中心化、透明和安全的应用，如加密货币交易，去中心化金融等。</li>
<li><strong>私有链</strong>：私有链具有链④的特性，中心化程度高、交易速度快、易于定制、隐私性强、扩展性强等等，但去中心化程度低、透明度低，安全性依赖于中心化，可能存在单点故障的风险；适用于需要一定程度中心化管理和更高隐私性的应用，如企业内部流程管理、供应链跟踪、数据分享平台等。</li>
<li><strong>联盟链</strong>：介于公有链和私有链之间，由多个组织共同维护，每个组织在自己的节点上维护一份区块链的复制品；与让任何人都可以加入和参与的公有链和通常只有一个组织或实体控制的私有链不同，联盟链的访问权限通常受到限制，只有经过授权的节点才能加入和参与网络的运行。联盟链具有部分去中心化、安全性较强、灵活性强、交易速度快、资源共享等优点，但存在中心化倾向、可拓展性受限、共识机制过于复杂、隐私保护受到挑战等问题；适用于跨境支付、供应链管理、行业协作平台等。</li>
<li>边缘链：具有高度分布式、高度安全、延迟低等优点，但网络连接不稳定，资源有限限制链的性能；适用于需要低延迟、高度安全和分布式的场景，如物联网、智能城市等。</li>
<li>混合链：结合了公有链和私有链特性，灵活性强、数据隐私保护性强、安全性高，可共享公共数据并合作，但混合链的设计与部署相对复杂，成本高，并且有中心化的趋向；适用于供应链管理、医疗保健、数字身份管理等。</li>
</ul>
<p><img src="C:\Users\wjx27\AppData\Roaming\Typora\typora-user-images\image-20240319200849546.png" alt="image-20240319200849546"></p>
</li>
<li><p><strong>区块链和比特币</strong>之间有着紧密的联系，但它们又是两个不同的概念。</p>
<p><strong>相同</strong>：</p>
<ul>
<li>起源：比特币是区块链技术的第一个且最著名的应用案例。</li>
<li>去中心化：两者都基于去中心化的概念，不依赖于中央权威机构来控制和验证交易。</li>
<li>分布式账本：比特币区块链同区块链技术一样，都是一种分布式账本技术，由多个节点共同维护和更新，每个节点都具有完整的账本副本。</li>
<li>不可篡改：比特币区块链通过加密技术和共识机制确保了交易记录的不可篡改性，任何人都无法在已经被确认的区块中修改交易记录。</li>
</ul>
<p><strong>不同</strong>：</p>
<ul>
<li>定义：区块链是一种分布式数据库技术，而比特币是一种数字货币，是一个基于区块链技术的应用，用于在网络中进行价值交换。</li>
<li>应用范围：区块链可以用于多种应用场景，如供应链管理、智能合约、身份验证、物联网等，不仅仅只限于数字货币；比特币仅作为一种加密货币存在，用于投资、交易和一些特定的商业应用。</li>
<li>中心化程度：比特币的区块链（公有链的一种典型代表）是完全去中心化的，没有单一的控制权，任何人都可以参与交易验证和区块生产。但其他应用场景下的区块链可能是中心化的、部分去中心化的或者完全去中心化的，具体取决于应用的设计需求。</li>
</ul>
<p>与比特币相关的其他虚拟货币还有：</p>
<ul>
<li>以太坊（Ethereum）： 以太坊是一个基于区块链技术的开放式平台，旨在支持智能合约和分布式应用程序的开发。它具有比特币一样的去中心化特点，但更加注重在区块链上实现智能合约和去中心化应用的可编程性。</li>
<li>莱特币（Litecoin）： 莱特币是比特币的一个衍生品，基于比特币的代码进行修改和改进而开发的，在技术上与比特币相似，但具有更快的交易确认时间和更高的供应量上限。</li>
<li>比特现金（Bitcoin Cash）： 比特现金是比特币的一个分叉币，旨在解决比特币的扩展性问题，通过增加区块大小来提高交易吞吐量。</li>
<li>瑞波币（Ripple&#x2F;XRP）： 瑞波币是一个开源的区块链支付协议和加密货币，旨在实现跨境支付和资金转移的便捷性和低成本性。它的设计目标是为金融机构提供一种高效的支付解决方案。</li>
<li>链克（Chainlink）： 链克是一个基于以太坊区块链的代币，它提供了一种连接智能合约和现实世界数据的解决方案，通过链克可以实现区块链与外部数据源的互操作性。</li>
</ul>
</li>
</ol>
<h2 id="2-进阶提升"><a href="#2-进阶提升" class="headerlink" title="2.进阶提升"></a>2.<strong>进阶提升</strong></h2><h3 id="分布式核心问题"><a href="#分布式核心问题" class="headerlink" title="分布式核心问题"></a><em>分布式核心问题</em></h3><ol>
<li><p><strong>一致性问题</strong>：区块链的一致性是通过共识机制（工作量证明PoW、权益证明PoS、重要性证明PoI、信任度证明MoT、实用拜占庭容错机制PBFT等）来实现的，共识机制是区块链网络中所有节点共同遵守的规则，它确保了即使节点之间可能存在分歧，整个网络也能就交易的有效性达成一致。一致性问题是指区块链网络中的所有节点是否能够就数据的准确性、顺序和完整性达成共识。区块链中存在的一致性问题有分叉、双花问题、51%算力攻击、拜占庭问题、网络分区等。如图表对比了几种共识机制。</p>
<p><img src="C:\Users\wjx27\AppData\Roaming\Typora\typora-user-images\image-20240314221703440.png" alt="image-20240314221703440"></p>
<p><strong>去中心化</strong>：去中心化是指在区块链网络中不存在单一的中心化控制权，而是由网络中的多个节点共同维护和管理整个系统。去中心化在很大程度上推进了“脱媒现象”的发生，不只是在金融领域，现在来看，去中心化的点对点系统在很多领域都巨大的潜力。</p>
</li>
<li><p><strong>挖矿和奖励机制</strong>：挖矿是指节点解决哈希难题并创建新区块的过程，而产出每个区块都需要解答高计算成本的哈希难题，为说服节点承担解谜责任的唯一方式就是为它们的有效工作提供奖励。因此，区块链算法规定节点提交有效区块将得到奖励，而为了维护系统的诚信，还有惩罚机制（收回区块奖励和取消奖励），竞争机制（速度竞争和质量竞争）。</p>
</li>
<li><p><strong>拜占庭问题和解决方法</strong>：拜占庭问题（即拜占庭将军问题）是一个分布式计算问题，它描述了在含有可能叛变的将军的军队中，如何通过相互通信达成一致的共识。我们可以将拜占庭将军问题简化为让所有忠诚的将军都能够让别的将军接收到自己的真实意图，并最终一致行动，而不受叛徒的干扰（在拜占庭问题中，假定信道传达消息是没有问题的，信道可能有问题的是两军问题和“三次握手”讨论“的范畴）。</p>
<p>在分布式系统中，拜占庭问题的主要特点包括以下三点。</p>
<ul>
<li>拜占庭节点：系统中的节点可能出现故障或者进行恶意操作，因此节点之间无法完全信任对方。</li>
<li>一致性：即使存在故障或者恶意节点，系统的所有诚实节点也需要就某个共同行动达成一致意见。</li>
<li>通信：节点之间的通信可能会受到网络延迟、消息丢失等因素的影响，存在延迟或者丢失。</li>
</ul>
<p>拜占庭问题的解决方法主要有两种，口头协议算法和书面协议算法，而在区块链中，共识算法是解决拜占庭问题的重要方法，如实用拜占庭容错算法（PBFT）、联邦拜占庭协议（FBA）、授权拜占庭容错算法（dBFT）等，被应用于解决区块链中的拜占庭问题。</p>
</li>
</ol>
<hr>
<h3 id="密码学安全和相关技术"><a href="#密码学安全和相关技术" class="headerlink" title="密码学安全和相关技术"></a><em>密码学安全和相关技术</em></h3><ol>
<li><p><strong>哈希算法</strong>：哈希算法是将输入的任意大小、类型的数据转换成固定长度的输出（哈希值）的方法。哈希值都是由十六进制数组成的字符串。哈希算法在给定的时间内只能接受一个数据，为其提供一个哈希值，而无法一次接受一堆独立的数据，为完成此任务，可采取以下模式：独立哈希、重复哈希、组合哈希、顺序哈希、<u>分层哈希（树状结构）</u>。</p>
<p>一类重要的哈希算法是加密哈希算法，它能够为任何类型的数据创建数字指纹，具有快速创建、确定性、伪随机、单向函数（不可逆性）、防碰撞（减少哈希冲突）等特点。</p>
<p>哈希算法的使用场景：</p>
<ol>
<li><p>通过对比哈希值对比数据→检测事件前后数据是否发生变化（原理：哈希计算的防碰撞性）</p>
</li>
<li><p><strong>哈希引用</strong>：把所存储数据的哈希值与存储数据的物理载体的信息结合在一起计算哈希值，一旦数据发生了变化，双方信息就无法保持一致，得出的哈希值也会发生变化。哈希引用可以用在任何需要维持数据原貌的场景，以防止用户使用系统误操作或人为破坏后产生的数据。同时，哈希引用还可以用于数据存储和检索，将哈希引用作为数据的索引，将数据存储在对应的哈希值所表示的位置。在数据检索时，通过输入数据计算哈希引用，然后根据哈希引用定位到相应的数据位置，实现快速检索。</p>
</li>
</ol>
<p><strong>哈希难题</strong>：哈希引用在区块链中最重要的概念，是哈希引用可以让数据之间进行复杂的计算，这种计算不能通过已有知识和数据的推理来解决，只能通过计算机运算来解决，所以哈希难题可视为一种运算难题，只能不断地去试错才能找到难题的解。</p>
<p>一个哈希难题包含以下四个要素：</p>
<ul>
<li><p>未经更改的已有数据</p>
</li>
<li><p>使用哈希</p>
</li>
<li><p>随机数</p>
<p>解答哈希难题的第一步就是猜一个随机数，并计算数据与随机数构成的数据集合的哈希值，然后根据限制条件去评估得到的哈希值，不断试错以找到满足限制条件的随机数（即这道哈希难题的解）。</p>
</li>
<li><p>限制哈希值</p>
<p>哈希难题使用的限制条件是有着标准格式的，哈希难题通常被称为难度，哈希难题的难度越高，需要的计算机运算能力越高。</p>
</li>
</ul>
</li>
<li><p><strong>非对称加密</strong>：非对称加密使用两种对应的密钥，并（人为的）分为公钥和私钥。被其中一个密钥加密的加密文档，只能使用另一个对应的密钥解密。使用公私钥的的两种方法，区别在于数据流通的方向。</p>
<ul>
<li><p>从公开到私密</p>
<p>此种用法比较直观，公钥的目的是将信息“传送”给私钥的拥有者（实际是因为只有拥有私钥的人才能解密文档）。可以把公钥比作邮箱地址，而私钥就是登录该邮箱的密码，只有私钥的拥有者才能打开邮件并阅读该“邮件”。</p>
</li>
<li><p>从私密到公开</p>
<p>私钥拥有者将信息用私钥加密后发布，人人都拥有公钥解密并阅读信息，但是只有私钥拥有者才能发布信息，这可以证明所有权，并衍生为第三点“数字签名“。</p>
</li>
</ul>
<p>区块链使用非对称加密加密，主要为实现以下两个目标。</p>
<ul>
<li><p>确认账户</p>
<p>区块链使用公钥作为用户的账户，确保用户和财产之间的对应关系。</p>
</li>
<li><p>授权交易</p>
<p>完成交易必须要能证明用户同意转移资产的所有权，这一过程就是第三点“数字签名”。</p>
</li>
</ul>
</li>
<li><p><strong>数字签名</strong>：数字签名等同于手写签名，是一种用于确保数字信息完整性、认证发送者身份以及抵御抵赖的技术手段。它利用了哈希引用和非对称加密技术对交易进行授权。</p>
<p>数字签名的实现通常包括以下步骤：</p>
<ol>
<li>创建数字签名：发送者使用哈希函数对要发送的消息进行哈希计算，生成消息的摘要或哈希值。 发送者使用自己的私钥对消息的哈希值进行加密，生成数字签名，并将数字签名附加到原始消息中一起发送给接收者。</li>
<li>公钥验证数字签名：接收者使用发送者的公钥对收到的数字签名进行解密，得到消息的哈希值。</li>
<li>哈希对比：接收者对接收到的消息进行哈希计算，得到消息的摘要或哈希值。</li>
<li>对比验证：接收者将解密后的哈希值与自己重新计算的哈希值进行比对，如果两者一致，则验证通过，否则验证失败。</li>
</ol>
<p>数字签名可以确保消息在传输过程中没有被篡改或损坏，并验证消息的发送者身份，防止伪造或冒充。而且，发送者无法抵赖已签名的消息，因为数字签名是使用私钥生成的，只有发送者才能生成正确的签名。</p>
</li>
<li><p><strong>数字证书</strong>：数字证书是一种用于认证和加密网络通信的电子文件，主要包括公钥、私钥、证书持有者信息和数字签名等部分，通常由权威可信的证书颁发机构（CA）签发，用于验证网络实体（如个人、网站或服务器）的身份。</p>
<p>数字证书的三点详细内容如下。</p>
<ul>
<li>信任链：浏览器或操作系统中预先安装了一组受信任的CA的根证书，当访问一个网站时，浏览器会检查该网站提供的数字证书是否由任何一个受信任的CA签发。</li>
<li>加密：数字证书包含了一对密钥中的公钥，用于加密数据，当与一个使用加密通信的网站进行通信时，浏览器会使用网站提供的公钥来加密发送的数据，以确保只有拥有相应私钥的接收方才能解密数据。</li>
<li>证书撤销：为应对数字证书因私钥泄露等原因而失效的情况，证书颁发机构会维护一个证书撤销列表（CRL）或使用在线证书状态协议（OCSP）来通知使用者一个证书的状态是否有效。</li>
</ul>
</li>
<li><p><strong>二叉树</strong>：二叉树是一种重要的数据结构，它是一种有序树，每个节点最多只有两个子节点，分为左子树和右子树，故也被称作有序二叉树。二叉树的表示方法主要有顺序存储和链式存储两种。顺序存储适合满二叉树和完全二叉树，使用数组表示；链式存储使用链表表示，包括二叉链和三叉链。</p>
<p>节点是二叉树的基本单元，每个节点包含一个数据元素以及指向左右子节点的指针，节点有以下几种类型。</p>
<ul>
<li><p>根节点： 二叉树的顶层节点，是整棵树的起始节点，通常用来表示整个树的引用。</p>
</li>
<li><p>父节点、子节点： 每个节点除了根节点外，都有一个父节点，同时可能有零个、一个或两个子节点。</p>
</li>
<li><p>叶子节点： 没有子节点的节点称为叶子节点，位于二叉树的最底层。</p>
</li>
</ul>
<p>下文提到的默克尔树就是二叉树的一种特殊形式。默克尔树在结构和应用上有一些特殊的设计，使其在数据完整性验证方面具有很高的效率和安全性，在许多分布式系统和区块链技术中被广泛应用于数据验证和完整性检查。</p>
<p><strong>默克尔树</strong>：一种使用哈希引用的数据结构，以及时发现数据是否被修改。通过把同一时间到达的不同区域的数据进行分组，然后通过单个的哈希引用来关联这些数据。如图所示，对每笔交易分别进行哈希引用（R1—R4），并两两成对进行分组，然后对这两对哈希引用再进行哈希引用，即R12和R34。重复该过程，直到最后只有一个哈希引用，也就是默克尔树的根（R）。</p>
</li>
</ol>
<p><img src="C:\Users\wjx27\AppData\Roaming\Typora\typora-user-images\image-20240314154415789.png" alt="image-20240314154415789"></p>
<ol start="6">
<li><p><strong>51%算力攻击</strong>：51%算力攻击是指在一个基于PoW的区块链网络中，如果一个个体或组织控制了网络中超过50%的计算能力，他们理论上可以发动攻击，通过控制整个分布式系统的集体决策过程，将现有权威链中的区块变成孤儿块，至少暂时的建立一个隐藏的中心控制节点以改变系统的状态，并建立一条包含对攻击发起者更有利的历史交易记录的新权威链，从而控制区块链的记账权，篡改历史交易记录和阻止合法交易的验证。实际上，成功实施这种攻击通常需要耗费巨大的资源，且区块链社区也制定了对应的机制抵御51%算力攻击，这使得在大多数时候攻击者都不太可能进行尝试。</p>
<p>事实上，任何试图操纵区块链的集体决策过程的企图，都是为了控制大部分的投票权，而区块链通过哈希难题将投票权与计算能力结合在一起，使任何试图控制大多数投票权的尝试，都需要收集整个点对点系统中大部分的计算能力。</p>
<p><strong>双花问题</strong>：双花问题有三种含义。</p>
<ul>
<li><p>复制数字商品引起的问题</p>
<p>通过复制代表了“加密货币”的数据片段，使得同一笔“加密货币”被同时多次使用。</p>
</li>
<li><p><strong>去中心化点对点分布式账本中存在的问题（重点含义）</strong></p>
<p>由于信息同步到整个去中心化系统上需要花费时间，同步信息慢的节点被其他拥有最新信息的节点所利用，导致在这个系统中出现同一个所有权在同一时间内的多次转移。</p>
</li>
<li><p>完全分布式点对点系统中违反完备性的一个例子</p>
<p>将第二种含义扩展，在各种场景的去中心化点对点系统中，节点之间花费时间同步信息更新数据所存在的问题，即去中心化点对点系统中数据一致性的问题。</p>
</li>
</ul>
</li>
<li><p><strong>P2P协议</strong>：P2P（peer-to-peer）协议是一种分布式网络通信协议，它允许两个或多个计算机（点）直接相互通信，不需要通过中央服务器。在P2P网络中，每个节点既是客户端又是服务器，可以提供资源，如文件、计算能力或数据存储空间，同时也能够请求其他节点的资源。（详细内容见下文<strong>P2P架构</strong>）</p>
</li>
</ol>
<hr>
<h3 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a><em>共识算法</em></h3><ol>
<li><p><strong>PoW</strong>：区块链中节点解决哈希问题的过程就叫做工作量证明（Proof of Work，PoW），PoW 共识算法的核心是不断地用随机数尝试求解哈希难题，PoW耗时与哈希难度成正比，哈希问题难度越大，所需的计算能力越大。第一个解决哈希难题的节点会得到区块奖励，并向网络证明其工作量，故区块链又俗称为“挖矿”。</p>
<p>PoW的基础原理与优缺点在哈希算法中已经介绍，此处不在赘述。</p>
<p>PoW主要用于确保网络的决策过程是去中心化的，抵御恶意攻击（如拒绝服务攻击，51%算力攻击）和防止双重支付问题（双花问题）。此外，一些区块链系统和加密货币也使用PoW来确保网络的安全性和可靠性。</p>
</li>
<li><p><strong>POS</strong>：权益证明(Proof of Stake，PoS)中引入了“币龄”的概念，币龄&#x3D;持有货币数量×持有时间。在PoS网络中前期通常会通过PoW机制发行一定数量的代币作为起始货币，在之后的PoS机制中矿工在挖矿时需要投入自己的币龄，投入的币龄越多挖矿的难度就越低，在成功出块后投入的币龄会被清空以保障公平性。若想在PoS网络中发起对主链的攻击行为，则需要攻击者持有大量代币，而事实证明有这样能力的用户做出恶意行为所得到的收益远远小于他作为一个诚实节点所得到的收益，因此PoS机制通过捆绑用户切身利益来保证交易的安全。</p>
<p>PoS共识的出现对解决PoW共识所消耗的大量算力与电力起到了一定的缓解作用，且缩短出块时间也能提高交易的处理速度和吞吐量，但PoS本质上还是需要通过哈希运算来竞争记账权且“币龄”的存在也降低了数字货币的流通性。而之后提出的权益委托证明共识(Dele-gated Proof of Steak，<strong>DPoS</strong>)引入了民主选举的方式，创建了”委员会“制度，保障了节点的利益，加快了出块速度的同时提高了交易速度和吞吐量，但是，“委员会”的形成会不可避免地带来一定程度的中心化，且首富会一定程度地对区块链的安全产生威胁。</p>
</li>
<li><p><strong>PBFT</strong>：PBFT 算法是一种拜占庭容错机制，基于拜占庭将军问题的解决方法原理设计而来，用于在分布式系统中达成共识，即使在一些节点出现故障或表现出恶意行为的情况下也能保持系统的可靠性。</p>
<p>在一个分布式网络中，假设全部节点的数量为<em>N</em>,恶意节点的数量为<em>f</em>，PBFT算法可以确保当恶意节点数量少于全网节点的1&#x2F;3即满足<em>N</em>≥3<em>f</em>+1时全网对消息达成共识。PBFT算法包含一个主节点和其余的从节点，首先通过轮换或随机算法选出某个节点为主节点，此后只要主节点不切换，则成为一个视图（view）。主节点以轮转 (round robin) 的方式交替更换。</p>
<p>当主节点正常工作时,消息需要经过请求（request）、预准备（pre-prepare）、准备（prepare）、承诺（commit）、答复（reply）5个阶段。PBFT算法的分布式共识过程如下：</p>
<ol>
<li><strong>request</strong>：客户端向主节点发送请求；</li>
<li><strong>pre-prepare</strong>：主节点在收到请求后生成预准备消息发送给全网备份节点；</li>
<li><strong>prepare</strong>：备份节点在收到预准备消息后首先进行验证，验证通过后生成准备消息发送给全网节点，同时监听网络中来自其他节点的准备消息；</li>
<li><strong>commit</strong>：在节点收到大于或等于2<em>f</em>+1个节点的准备消息后生成承诺消息,同时监听网络中来自其他节点的承诺消息；</li>
<li><strong>reply</strong>：当节点收到大于或等于2<em>f</em>+1个节点的承诺消息后完成对消息的承诺，并更新自己的日志，同时将承诺信息反馈给客户端。当客户端收到超过<em>f</em>个节点的承诺信息时,表明该请求被大多数节点确认。</li>
</ol>
<p><img src="C:\Users\wjx27\AppData\Roaming\Typora\typora-user-images\image-20240319232944945.png" alt="image-20240319232944945"></p>
<p>在PBFT中, 存在<strong>检查点 （checkpoint） 机制</strong>， 由于每个消息都被赋予了一定的序列号，如消息m对应的序列号为118，当不少于2<em>f</em>+1个节点组成消息m的承诺凭证，完成消息承诺之后，序列号118成为当前的稳定检查点 （stable checkpoint）。检查点机制被用于实现存储删减，即当历史日志内容过多时，节点可以选择清除稳定检查点之前的数据，减少存储成本。</p>
<p>另外，稳定检查点在PBFT的视图转换中也起到了关键作用。如果主节点出错，不能及时处理数据，超时无响应或其他节点大多数认为其存在问题时，则会启动视图转换协议，从备份节点中选择新的主节点继续完成工作。PBFT的视图转换过程如下：</p>
<ol>
<li><strong>视图转换信息广播</strong>：备份节点I*的当前视图V, 当前稳定检查点S*, 对于稳定检查点S*的凭证C (即2<em>f</em>+1个节点的有效承诺凭证) 。U为节点I*当前视图下，序列号大于S*，且已经形成准备凭证的消息集合。节点I计算视图转换消息 , 并将其在全网广播。</li>
<li><strong>视图转换确认</strong>：备份节点收集对视图V+1的转换消息并验证其合法性, 验证通过后计算视图转换确认消息。备份节点将消息i直接发送给视图V+1对应的新的主节点。视图V+1的主节点由轮转方式决定。</li>
<li><strong>新视图广播</strong>：对于每个视图转换消息，如节点J*的消息vcj，如果vcj合法，则其他节点将会向主节点发送对vcj的视图转换确认消息，因此，当主节点收集到2<em>f</em>-1个对vcj的视图转换确认消息，则可认为vcj有效，并将vcj和其对应的视图转换确认消息放入到集合S中。主节点收集其他节点的有效视图转换消息，如果S中消息不少于2<em>f</em>个，则主节点计算新视图消息，其中包括当前的稳定检查点和稳定检查点之后序列号最小的预准备消息。</li>
</ol>
<p>PBFT及其改进算法的应用场景主要在以Hyperledger Fabric为代表的联盟链中，联盟链中取消了激励机制，采用PBFT算法可以避免大量算力及电力资源等的浪费。</p>
</li>
<li><p><strong>PoVT</strong>：PoVT（Proof of Value and Trust）共识算法结合了价值和信任的概念，与其他共识算法（如PoW和PoS）不同，PoVT算法主要关注的是参与者的价值和信任级别，而不是计算能力或资金量。</p>
<p>在PoVT共识算法中，参与者被要求展示其对网络的价值和信任，这通常通过验证者提供的价值和信任证据来实现。价值证据可能包括参与者的历史贡献、资源投入或其他形式的证明，而信任证据则可能涉及参与者的声誉、信用评级等信息。一旦参与者提供了足够的价值和信任证据，他们就有资格参与区块链网络的共识过程，例如提议和验证交易，并且会根据参与者提供的证据权重来决定其在共识过程中的影响力。</p>
<p>PoVT相对于PoW对能源的利用更高效，相对于PoS对持币者更公平，并且更重视网络参与者的价值和信任。</p>
<p>（关于PoVT的信息真的很少）</p>
</li>
</ol>
<hr>
<h3 id="网络部分"><a href="#网络部分" class="headerlink" title="网络部分"></a><em>网络部分</em></h3><ol>
<li><p><strong>分布式系统</strong>：分布式系统是由多个独立计算机节点组成的计算机系统，这些节点通过网络进行通信和协作，共同完成一组任务。分布式系统的设计目标是将计算机资源、数据和控制权分布在多个节点上，以提高系统的可靠性、可扩展性和性能。</p>
<p>相比于集中式系统，分布式系统允许多个节点在没有中心控制的情况下协同工作，且由多个组件组成，这些组件可以在不同的计算机上运行，并通过网络进行通信，具有更高的可扩展性、容错性和灵活性等优势，因此广泛应用于大规模数据处理、高并发访问、分布式存储等领域。由于分布式系统中的节点是相互独立的，因此单个节点的故障不会影响整个系统的运行。当一个节点出现故障时，其他节点可以继续工作，从而保证系统的可用性。而通过添加更多的计算机节点，分布式系统可以轻松地扩展到处理更大的工作负载。这种扩展性使得分布式系统成为处理大数据和高并发请求的理想选择。</p>
<p><strong>基本原理</strong>：分布式系统的设计需要考虑以下几个方面。</p>
<ul>
<li><p>分布式计算：分布式系统通过将计算任务分解成更小的子任务，分配给不同的节点进行处理来提高处理能力和效率。每个节点可以执行一部分任务，并通过网络与其他节点通信和协作，共同完成复杂的任务。</p>
</li>
<li><p>通信模型：分布式系统的通讯模型是指多个节点之间进行通信和协作的方式和规则。通过定义通讯模型，可以确保多个节点之间的交互是可靠、安全和高效的。</p>
<p>通讯模型通常由以下四种组件组成：</p>
<ul>
<li>通信协议：用于定义节点之间交换消息和数据的格式和规则，包括消息头、消息体和校验和等内容。</li>
<li>传输协议：用于在不同的物理节点之间传输数据，包括 TCP&#x2F;IP、UDP 和 HTTP 等。</li>
<li>通信接口：用于在节点之间建立和维护通信连接，包括套接字、RPC 和消息队列等。</li>
<li>分布式算法：用于协调节点之间的交互，包括一致性算法、领导选举算法和分布式锁算法等。</li>
</ul>
<p>通讯模型可以分为客户端-服务器（P\S）模型、P2P模型、发布-订阅（P\S）模型和消息队列模型四种。</p>
</li>
<li><p>数据一致性：在分布式系统中，数据分布在多个节点上，并且由于多个节点可以同时访问和修改数据，分布式系统需要协调和管理这些数据，确保数据的正确性、一致性和可用性。分布式数据库、分布式文件系统和缓存系统（如Redis、Memcached）等是实现这一原理的技术。</p>
<p>数据一致性通常可以分为以下几个层次：</p>
<ul>
<li>强一致性：在强一致性模型中，无论何时对数据进行读取，都会获得最新的、一致的数据。在这个模型中，当一个节点修改数据时，这个修改操作会立即被其他节点感知，并且在修改操作完成之前，其他节点不能访问该数据。</li>
<li>弱一致性：在弱一致性模型中，读取操作可能会返回旧的数据或者数据的不同副本。在这个模型中，修改数据的操作不会立即被其他节点感知，而是在一段时间内逐渐传播到其他节点。</li>
<li>最终一致性：在最终一致性模型中，数据最终会达到一致状态，但在某些时间点下可能会出现数据不一致的情况。在这个模型中，节点之间可能存在数据同步的延迟，但是最终数据会达到一致状态。</li>
</ul>
<p>为了实现一致性，系统可以采用一致性协议和算法，确保节点在进行数据更新时达成一致的决策。以下是几种常见的算法：</p>
<ul>
<li>一致性哈希算法：一致性哈希算法将数据映射到一个哈希环上，并将哈希环划分为多个区域，每个区域由单个节点负责。当节点失效时，其负责的区域将被其他节点接管，从而保证数据访问的一致性。</li>
<li>Paxos算法：多个节点通过投票来决定数据的修改或复制，通过提议、接受和学习三个阶段来确保数据一致性。</li>
<li>Raft算法：通过领导者选举、日志复制和安全性机制实现分布式系统的高可用性和一致性。相比于Paxos算法，Raft更直观、易于理解和实现。</li>
<li>2PC（Two-Phase Commit）算法：2PC算法是一种用于在分布式系统中执行事务的算法，多个节点通过协调器来达成一致性，确保事务的所有操作要么全部执行，要么全部回滚。</li>
</ul>
</li>
<li><p>分布式锁和同步：在多节点环境中，需要同步对共享资源的访问，以防止并发问题。分布式锁是一种机制，用于在多个节点上实现对共享资源的互斥访问。</p>
</li>
<li><p>负载均衡：负载均衡是指在分布式系统中，将请求合理地分配到多个节点上，避免节点出现过载或空闲情况，以实现系统资源的均衡利用和提高系统的可用性、可扩展性和性能。负载均衡通常用于Web应用程序、数据库系统、分布式存储系统和分布式计算等场景。</p>
<p>负载均衡通常可以分为以下几种类型：</p>
<ul>
<li>硬件负载均衡：通过专用的负载均衡设备（如负载均衡器）来分配请求，具有高可靠性和高性能，但是成本较高。</li>
<li>软件负载均衡：通过软件来实现负载均衡，通常运行在普通的计算机上，成本较低，但性能和可靠性可能会受到影响。</li>
<li>DNS负载均衡：通过DNS服务器来分配请求，根据请求的来源地理位置或者负载情况来选择相应的节点。</li>
<li>内容分发网络（CDN）：通过在全球范围内部署缓存服务器，将静态内容分发到离用户最近的节点，从而提高访问速度和可用性。</li>
</ul>
<p> 负载均衡的实现通常依赖于以下几个因素：</p>
<ul>
<li><p>负载均衡算法：负载均衡算法用于决定将请求分配给哪个节点。常见的负载均衡算法包括轮询（Round-Robin）、最小连接数（Least Connections）和IP哈希（IP Hash）等。</p>
</li>
<li><p>监控和自动化：负载均衡系统应该能够实时监控节点负载和性能，并自动调整请求分配策略，以保证系统的可用性和性能。</p>
</li>
<li><p>容错和故障转移：负载均衡系统应该能够检测节点故障并自动将请求转移到其他可用节点，从而实现容错和故障转移。</p>
</li>
<li><p>容错处理：容错处理是指在分布式系统中，通过多种手段来保证系统的可靠性和稳定性，以应对节点故障、网络故障、硬件故障等各种意外情况，确保即使这些情况下，系统仍能够继续运行和提供服务。</p>
<p>常用的容错处理技术包括：</p>
<ul>
<li>冗余备份：将数据、服务或节点复制到多个地方，当一个节点或服务出现故障时，可以从备份节点或服务中恢复。</li>
<li>心跳检测：通过定期向节点发送心跳包，来检测节点的状态和可用性。当节点不再响应心跳包时，可以判断节点已经故障，并采取相应的措施。</li>
<li>选举算法：确保当主节点或领导者出现故障时，能够自动选举出新的主节点或领导者来协调节点之间的操作。</li>
<li>消息确认机制：确保消息的可靠传递，当消息未被正确确认时，可以采取相应的措施。</li>
<li>分布式锁：当多个节点需要竞争共享资源时，确保只有一个节点能够访问该资源，从而避免数据的冲突和错误。</li>
</ul>
</li>
<li><p>安全性 ：分布式系统保障系统和数据的机密性、完整性、可用性和认证性的能力，这包括数据的加密、访问控制、身份验证等方面的安全机制。分布式系统还需要防范各种安全威胁，如拒绝服务攻击、数据篡改等。</p>
<p>在分布式系统中保证安全性需要考虑以下几个方面：</p>
<ul>
<li>认证和授权：安全系统通常需要实现认证和授权机制，以确保只有授权的用户或进程能够访问资源和执行操作。</li>
<li>加密和解密：用于保护数据的机密性，以防止数据被未经授权的用户或进程访问。</li>
<li>安全传输协议：安全传输协议（如TLS&#x2F;SSL）可以确保在网络上传输的数据是加密的，以保护数据的机密性和完整性。</li>
<li>安全存储：安全存储可以确保数据在存储时受到保护，以防止数据被未经授权的用户或进程访问。</li>
<li>安全审计：安全审计可以记录系统中的操作和事件，以便对系统进行监控和分析，发现和解决潜在的安全问题。</li>
<li>防火墙和入侵检测系统：防火墙可以限制网络上的流量和连接，以保护系统免受网络攻击。入侵检测系统可以监测系统中的异常行为和攻击，以及及时采取相应的措施。</li>
</ul>
<p>需要注意的是，安全性是一个不断演化的领域，新的安全问题和威胁不断出现。为了确保系统的安全性，需要定期评估和更新安全策略，并采取相应的措施来应对新的安全问题和威胁。</p>
</li>
<li><p>拓展性：扩展性是指在分布式系统中，通过增加节点或资源来扩展系统的容量和性能的能力。扩展性是分布式系统设计和实现的一个重要目标，因为分布式系统通常需要处理大量的数据和请求，需要具备可扩展性来应对不断增长的负载。<br>在分布式系统中，实现扩展性考虑以下几个方面：</p>
<ul>
<li>横向扩展：通过添加新的节点来分担负载，扩展系统的容量和性能。</li>
<li>纵向扩展：通过增加节点的硬件规格（如CPU、内存、存储等）来提高节点的处理能力，来扩展系统的容量和性能。</li>
<li>负载均衡：见上文，不再赘述。</li>
<li>数据分片：数据分片是将数据分散到多个节点上，以实现数据的分布式存储和查询。数据分片可以通过增加节点来扩展系统的存储容量和查询性能。</li>
<li>异步处理：通过将请求分发到多个节点上并异步处理，避免单个节点因为处理请求而被阻塞，从而提高系统的并发性能。</li>
</ul>
<p>扩展性不仅仅是增加节点或资源，还需要考虑系统的设计和实现是否具备可扩展性，系统的架构、数据模型、算法等都可能会影响系统的扩展性。因此，在设计和实现分布式系统时，应该考虑系统的可扩展性，并采取相应的措施来保证系统的可扩展性。</p>
</li>
<li><p>自治性：每个节点在分布式系统中具有一定的自治性，可以独立地做出决策和执行任务，而不需要依赖中央控制器，这样可以提高系统的灵活性和可扩展性。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>点对点网络</strong>：P2P网络（点对点网络，Peer-to-Peer Network）是一种分布式网络，网络的参与者共享他们所拥有的一部分硬件资源（处理能力、存储能力、网络连接能力、打印机等），这些共享资源需要由网络提供服务和内容，能被其它对等节点（peer）直接访问而无需经过中间实体。在此网络中的参与者既是资源提供者（server），又是资源获取者（client）。P2P架构具体有两种，一种是完整连接拓扑架构，每个客户端与其他每个客户端之间都有连接，信息可以直接在用户间交换；另一种是环状拓扑架构，信息只有流经一个或多个客户端后才能传递过来。</p>
<p>关于P2P的典型定义有以下四种：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">P2P 工作组</td>
<td>通过系统间直接交换来共享计算机资源和服务。</td>
</tr>
<tr>
<td align="center">Intel工作组</td>
<td>通过在系统之间直接交换来共享计算机资源和服务的一种应用模式。</td>
</tr>
<tr>
<td align="center">IBM</td>
<td>由若干互连协作的计算机构成的系统，且至少具有以下特征之一：系统依存于边缘化（ 非中央式服务器）设备的主动协作，每个成员直接从其他成员而不是从服务器的参与中受益；系统中成员同时扮演服务器与客户端的角色；系统应用的用户能够意识到彼此的存在，构成一个虚拟或实际的群体。</td>
</tr>
<tr>
<td align="center">HP</td>
<td>一类采取分布式方式利用计算能力、存储空间、数据、网络带宽等分布式资源完成分布式计算、数据内容共享、通信与协作或平台服务等功能的系统。</td>
</tr>
</tbody></table>
<p>P2P网络的三类体系结构：</p>
<table>
<thead>
<tr>
<th>体系结构</th>
<th>特点</th>
<th>优点</th>
<th>缺点</th>
<th>典型协议</th>
</tr>
</thead>
<tbody><tr>
<td>混合式对等网络</td>
<td>含有中心索引服务器，记录内容的索引和节点必要信息，辅助节点之间建立连接，而内容本身存储在节点中内容的传递只在节点之间进行。</td>
<td>查询机制简单高效，易于维护</td>
<td>可扩展性差</td>
<td>Napster、Bt等</td>
</tr>
<tr>
<td>无结构对等网络</td>
<td>网络拓扑是任意的，内容的存储位置与网络拓扑无关；对等节点之间通过客户端软件搜索网络中存在的对等节点，并直接交换信息。</td>
<td>设计简洁，分布式管理</td>
<td>通信负担过大，可扩展性差，查询结构不确定</td>
<td>Gnutella、Freenet、FastTrack、KaZaA等</td>
</tr>
<tr>
<td>结构化对等网络</td>
<td>基于分布式哈希表，网络拓扑结构有严格规律，每个节点都随机生成一个标志（ID），内容的存储位置与节点标志之间存在映射关系。</td>
<td>严格的覆盖式网络结构，可扩展性良好</td>
<td>具体实现复杂，且难以实现模糊查询</td>
<td>Chord、Pastry、CAN、Tapertsry等</td>
</tr>
</tbody></table>
<p>P2P系统涉及的关键技术包括覆盖网络、消息路由与定位、资源搜索、系统的自适应和容错性以及它的激励机制、信任模型和安全问题等。</p>
<ul>
<li>覆盖网络：搭建在物理网络之上的逻辑网络，提供资源发现与定位服务。覆盖网的优劣直接影响查询效率。</li>
<li>资源搜索方法：混合结构对等网络采用集中目录模型搜索方法查询需要O（1）步；无结构对等网络一般采用洪泛请求模型搜索方法，查找需要O（N）步（Ｎ为节点数）；结构化对等网络采用文件路由模型搜索方法，查找需要O（logN）步。</li>
<li>自适应问题：对等网络具有很强的动态性。动态性体现在不断地有新节点加入、旧节点离开、节点失效等情况发生。自适应问题研究对等网络如何处理并修复各种动态性情况，特别是节点失效问题的处理，从而确保其正常运行。</li>
<li>容错性：对等网络中发生错误时的避免方法或补救措施，如节点失效问题、节点引发的热点问题、安全问题、信誉问题等。</li>
<li>激励机制：P2P网络中的激励机制大多数都是针对P2P文件系统中的搭便车问题提出的抑制机制。目前已有的激励机制有基于社会网络或经济关系、博弈论、声誉和机制设计的四种激励方法。</li>
<li>信任模型：P2P系统信任机制的研究内容主要包括信任链管理、信任自动协商和声誉系统三大类。目前的信任模型大体分为静态模型和动态模型两大类。</li>
<li>安全问题：P2P安全问题分为底层技术方面和非技术性方面两大类。底层技术方面的安全问题（如监听或中断网络通信、窜改或伪造虚假数据等）及其安全策略主要通过计算机网络安全中的相关技术（如加密、数字签名等） 解决;非技术方面安全问题是版权问题、管理问题和垃圾信息问题等。</li>
</ul>
<p>P2P网络的主要特点包括:</p>
<ul>
<li>去中心化：与C&#x2F;S不同，P2P网络不依赖于中心化的服务器，所有的节点对等，共同构成分布式网络。</li>
<li>直接通信：P2P网络中的节点可以直接相互通信，无需经过中间服务器。节点可以在网络中发现其他节点，并与其建立连接，进行数据传输、资源共享或者信息交换。</li>
<li>资源共享：每个节点都可以贡献自己的资源，同时也能利用其他节点的资源，有效利用网络中闲置的计算能力和存储空间。</li>
<li>高效率：在某些应用场景中，如文件分享，P2P协议可以显著提高传输速度，因为数据可以直接从源节点传输到目标节点，而不需要经过中心服务器。</li>
<li>鲁棒性：由于没有中心节点，P2P网络在部分节点失效时仍然能够继续工作，具有较强的容错性。</li>
<li>自组织性： 节点之间可以自行组织形成网络拓扑结构，进行路由选择和数据传输。节点之间可以通过协议进行协商和合作，共同维护网络的稳定性和可靠性。</li>
<li>可扩展性：P2P网络容易扩展，新节点加入网络简单，不需要复杂的配置，网络可以随着节点的增加而扩展。</li>
<li>分布式哈希表（DHT）： DHT是一种分布式存储和查找技术，常用于P2P网络中的节点发现和资源定位。它将数据分布在网络中的各个节点上，并通过哈希算法来确定数据的存储位置和查找路径。</li>
<li>安全性和隐私保护： P2P网络通常提供一定程度的安全性和隐私保护机制，包括数据加密、身份验证、匿名通信等，以保护用户的数据和隐私不受攻击和侵犯。</li>
</ul>
<p><strong>B&#x2F;S</strong>架构（Browser&#x2F;Server）、<strong>C&#x2F;S</strong>架构（Client&#x2F;Server）同P2P架构的<strong>区别</strong>：</p>
<ul>
<li><p>客户端形式：B&#x2F;S和C&#x2F;S通常有专门的客户端（B&#x2F;S是浏览器，C&#x2F;S是专门的应用程序），而P2P的每一个节点（普通的计算机或设备）都可以作为客户端。</p>
</li>
<li><p>中心化属性：B&#x2F;S和C&#x2F;S有明显的中心化属性（服务器或客户端），而P2P不依赖于中心化的服务器，所有的节点对等，共同构成分布式网络。</p>
</li>
<li><p>通信方式：B&#x2F;S和C&#x2F;S通过客户端或服务器端进行通信，P2P则是节点之间直接通信。</p>
</li>
<li><p>网络结构：B&#x2F;S和C&#x2F;S通常有明确的中心服务器，P2P则是去中心化的网络结构。</p>
</li>
<li><p>维护和更新：B&#x2F;S和C&#x2F;S的维护和更新主要在服务器端进行，P2P则需要在各个节点上进行。</p>
</li>
<li><p>适用场景：B&#x2F;S 架构具有部署和维护成本低、跨平台性强等优点，适用于 Web 应用程序和服务，C&#x2F;S 架构具有响应速度快、用户体验好等优点，适用于需要较高性能和复杂功能的应用程序，而P2P具有去中心化、高可扩展性等优点，适于实现文件共享、实时通信等功能，适合需要去中心化和弹性的场景。</p>
</li>
</ul>
</li>
<li><p><strong>TCP&#x2F;IP</strong>:TCP&#x2F;IP（传输控制协议&#x2F;互联网络协议，Transmission Control Protocol &#x2F; Internet Protocol）<strong>协议族</strong>是一组协议的集合，也叫互联网协议族，用来实现互联网上主机之间的相互通信。。TCP和IP是其中两个很重要协议，所以用TCP&#x2F;IP来命名这个互联网协议族，实际上还包括其他协议，比如UDP、ICMP、IGMP、ARP&#x2F;RARP等。</p>
<p><strong>TCP</strong>协议：互联网运输层有两大协议，一是面向连接的TCP协议，另一协议是UDP（用户数据报协议，User Datagram Protocol）。两个对等运输实体在通信时传送的数据单位叫做运输协议数据单元TPDU(Transport Protocol Data Unit)。TCP传送的协议数据单元是TCP报文段（segement）。</p>
<ul>
<li><p>运输层的<strong>端口号</strong>：运行在计算机中的进程是用进程标识符来标志的，为了使运行不同操作系统的计算机的应用进程能够互相通信，我们在传输层使用协议端口号或端口对 TCP&#x2F;IP 体系的应用进程进行标志。虽然通信的终点是应用进程，但只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP &#x2F; UDP 来完成。端口号只具有本地意义，它只是为了标志本地计算机应用层的各个进程在和传输层交互时的层间接口。</p>
<blockquote>
<p>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址。</p>
</blockquote>
<p>端口号有两种基本分配方式：</p>
<ul>
<li>全局分配：这是一种集中分配方式，由一个公认权威的中央机构根据用户需要进行统一分配，并将结果公布于众。</li>
<li>本地分配：又称动态连接，即进程需要访问传输层服务时，向本地操作系统提出申请，操作系统返回本地唯一的端口号，进程再通过合适的系统调用，将自己和该端口连接起来。</li>
</ul>
<p>端口号可以分为三大类：</p>
<ul>
<li>公认端口：一般从0到1023，它们紧密绑定于一些服务。通常这些端口的通讯明确表明了某种服务的协议。</li>
<li>注册端口：从1024到49151。使用这个范围的端口号必须在IANA登记，以防止重复。</li>
<li>动态&#x2F;客户端口：从49152到65535。留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号，通信结束后，这个端口号可供其他客户进程以后使用。</li>
</ul>
</li>
<li><p><strong>UDP</strong>协议：UDP协议只在IP的数据报服务之上增加了复用、分发及差错检测的功能。UDP传送的协议数据单元是UDP报文或用户数据报。</p>
<p>UDP协议的主要特点有：</p>
<ul>
<li>无连接：UDP在数据传输之前不需要建立连接，因此它比TCP更加高效，但也牺牲了可靠性。</li>
<li>不可靠：UDP不保证数据包的可靠到达，发送的数据报可能到达目的地，也可能丢失或顺序错乱。</li>
<li>面向事务：UDP提供的是尽最大努力交付服务，即传送的数据报可能出错、重复、顺序错乱，不保证可靠交付，应用程序需要负责处理这些问题。</li>
<li>面向报文：UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，即应用层交给UDP多长的报文，UDP就照样发送即一次发送一个报文。所以应用程序要选择合适大小的报文。传输层从IP层收到UDP数据报时，根据首部中的目的端口，把UDP数据报通过相应的端口，上交给应用进程。</li>
<li>无拥塞控制：UDP没有拥塞控制机制，网络出现拥塞不会使源主机的发送速率降低。</li>
<li>多种通信：UDP支持一对一，一对一多，多对一，多对多的交互通信。</li>
<li>小头部开销：UDP的头部比TCP的头部小，只有8个字节，减少了网络开销。</li>
</ul>
</li>
<li><p>TCP的特点如下：</p>
<ul>
<li><p>面向连接：TCP在数据传输之前，需要先进行“握手”，建立TCP连接。</p>
</li>
<li><p>一对一连接：每一条 TCP 连接只能有两个端点 (endpoint)，每一条 TCP 连接只能是点对点的（一对一）。</p>
</li>
<li><p>可靠传输：TCP通过序列号、确认应答、重传机制等方法，确保数据的可靠传输。</p>
</li>
<li><p>面向字节流：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流。TCP并不知道所传送字节流的含义。TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块大小一样，但接收方应用程序收到的字节流和发送方应用程序所发出的字节流完全一样。</p>
</li>
<li><p>兼容性：TCP协议可以与多种不同的网络层协议（如IP）和应用层协议（如HTTP、FTP等）配合使用。</p>
</li>
</ul>
</li>
<li><p>TCP 的连接：TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口，而是<strong>套接字</strong> (socket) 。端口号拼接到 (contatenated with) IP 地址即构成了套接字（又叫做接口）。</p>
</li>
<li><p>TCP报文段的首段格式：</p>
<ul>
<li>源端口号和目的端口号：TCP与UDP一样，首部包含源端口号和目的端口号，用于多路复用&#x2F;分解来自或送到上层应用的数据。</li>
<li>检验和字段：8比特，同UDP一样，TCP首部也包含检验和字段，其检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</li>
<li>序号字段：32比特，是本报文段所发送的数据的第一个字节的序号。</li>
<li>确认号字段：32比特，是期望收到对方的下一个报文段的数据的第一个字节的序号。</li>
<li>接受窗口字段：16比特，用于流量控制，指示接收方愿意接受的字节数量。</li>
<li>首段长度字段：4比特，指示了以32比特的字为单位的TCP首部长度，由于选项字段的原因，TCP首部的长度是可变的。</li>
<li>选项字段：可选变长，用于发送方与接收方协商最大报文段长度（MSS），或在高速网络环境下用作窗口调节因子时使用。首部字段中还定义了一个时间戳选项。</li>
<li>标志字段：6比特，标志字段有ACK、PSH、RST、SYN、FIN和URG等，指示的含义不同，用法也不同。<ul>
<li>确认ACK：用于指示确认字段中的值是有效的，当ACK&#x3D;1，确认号字段有效，当ACK&#x3D;0，确认号字段无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1。</li>
<li>推送PSH：当两个进程通信时，有时一端的进程希望键入一个命令后，能立即收到对方的响应，这时TCP就可以将PSH&#x3D;1，并立即创建一个报文段发送出去，接收方TCP收到PSH&#x3D;1，就会尽快交付给接收端进程，而不会再等整个缓存填满后再交付。</li>
<li>复位RST ：当 RST&#x3D;1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接RST置1可以用来拒绝一个非法的报文段或者拒绝打开一个连接。</li>
<li>同步SYN：在建立连接时用来同步序号，当SYN&#x3D;1&amp;&amp;ACK&#x3D;0，表示这是一个请求连接的报文段，若对方同意建立连接，则在响应报文段中使得SYN&#x3D;1&amp;&amp;ACK&#x3D;1。故SYN&#x3D;1：表示这是一个连接请求和连接接收报文。</li>
<li>终止FIN：用来释放一个连接，当FIN&#x3D;1，表示此报文段发送方的数据发送完毕，并要求释放连接。</li>
<li>紧急URG：紧急数据的最后一个字节由16比特的紧急数据指针字段指出，当 URG &#x3D;1 时，表明紧急数据指针字段有效，告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。</li>
</ul>
</li>
</ul>
</li>
<li><p>TCP <strong>可靠传输</strong>的实现：</p>
<ul>
<li>超时重传：TCP 每发送一个报文段，就对这个报文段设置一次计时器，如果不能及时收到一个确认，将重发这个报文段。这种可靠的传输协议被称为：自动重传请求(Automatic Repeat reQuest，ARQ)。</li>
<li>检验和：利用TCP报文头的校验和检测数据在传输过程中是否变化。如果改变，就丢弃这个报文段让发送端重传。</li>
<li>排序：TCP发送方给每一个数据包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 且TCP的接收端会丢弃重复的数据包。</li>
<li>滑动窗口技术：发送端发送一个数据包之后不需要等到对方应答后在发下一个数据包，只要发送的字节还没超过滑动窗口的大小就可以一直发送。在收到接收端的应答后滑动窗口开始移动。</li>
<li>流量控制：当接收端来不及处理发送端的数据，就减小自己的接收窗口，同时发送端也减小自己的发送窗口或者直接调成0，接收端处理完缓存里的数据在调整窗口开始接收数据包。</li>
</ul>
</li>
<li><p><strong>TCP的传输连接管理</strong>：TCP传输连接有三个阶段，即：连接建立、数据传送、连接释放。TCP连接的建立采用客户-服务器方式。</p>
<ol>
<li><p>连接建立：握手需要在客户和服务器之间交换三个 TCP 报文段。称之为“三报文握手”或“三次握手”。采用三报文握手主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。</p>
<ol>
<li><p>第一次握手：   建立连接之前客户端要保证服务器已经开始监听，然后客户端选择一个随机的端口开始和服务器进行socket通信。客户端向服务器发送建立连接的请求报文段，首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x，进入SYN-SENT（同步以发送状态）。等待服务器确认；</p>
</li>
<li><p>第二次握手：服务器收到该报文段后，向客户端发送确认，在确认报文段中SYN位和ACK位都置1，确认号ack&#x3D;x+1，初始序号ack&#x3D;y，此时服务器进入SYN_RECV状态，该允许的连接的报文段被称为SYNACK报文段。</p>
</li>
<li><p>第三次握手：客户端收到服务器的确认（SYNACK报文段）后，开始给该连接分配缓存和变量，同时还要向服务器给一个确认，确认报文段的ACK是1，确认号ack&#x3D;y+1，自己的序号seq&#x3D;x+1，客户端进入ESTABLISHED（建立连接）状态，服务器收到客户端的确认后也进入建立连接状态。</p>
<p><img src="C:\Users\wjx27\AppData\Roaming\Typora\typora-user-images\image-20240321171326236.png" alt="image-20240321171326236"></p>
</li>
</ol>
</li>
<li><p>数据传送：完成“三次握手”后，客户和服务器就可以互相发送包括数据的报文段了。在以后得每一个报文段中，SYN比特都将被置为0。</p>
</li>
<li><p>连接释放：TCP 连接释放过程是四次挥手，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。</p>
<ol>
<li><p>第一次挥手： 客户端先发送一个连接释放的报文并停止发送数据。该报文段首部的终止控制位FIN&#x3D;1，序号seq&#x3D;u（客户端上次传送数据最后一个字节的序号加1），并进入FIN-WAIT-1（终止等待1）状态，等待服务器的确认。</p>
</li>
<li><p>第二次挥手：服务器收到该报文段后就发出确认，该报文段的确认号ack&#x3D;u+1， 序号seq&#x3D;v（服务器上次发送数据最后一个字节的序号加1），进入了CLOSE&#x3D;WAIT（关闭等待）状态。</p>
</li>
<li><p>第三次挥手：客户端收到服务器的确认后，就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文。服务器向客户端发送连接释放的报文段，该报文段的终止控制位 FIN&#x3D;1，重复上次的确认号ack &#x3D; u + 1，序号 seq &#x3D; w（半关闭状态服务器可能向客户端发送了一些数据），进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p>
</li>
<li><p>第四次挥手 ： 客户端收到连接释放报文段后，给服务器一个确认结束的报文段，该报文段确认号ack &#x3D; w + 1，序号 seq &#x3D; u + 1。此时客户端就进入TIME-WAIT（时间等待）状态，服务器进入CLOSED（关闭）。客户端经过2*MSL（最长报文段寿命）的时间后（4分钟）后也进入关闭。</p>
<p><img src="C:\Users\wjx27\AppData\Roaming\Typora\typora-user-images\image-20240321172202190.png" alt="image-20240321172202190"></p>
</li>
</ol>
<p>需要“四次挥手”的原因：由于TCP是全双工模式，在关闭连接时，客户端发出FIN报文段，只是表示客户端告诉服务端数据已经发送完毕了。当服务端收到FIN报文并返回ACK报文段，表示它已经知道客户端没有数据发送了，但是服务端还是可以发送数据到客户端的，所以服务端很可能并不会立即关闭SOCKET，直到服务端把数据也发送完毕。当服务端也发送了FIN报文段时，这个时候就表示服务端也没有数据要发送了，就会告诉客户端服务端也没有数据要发送了，之后彼此就会中断这次TCP连接。</p>
<p>需要等待2*MSL时间的原因：</p>
<ul>
<li>保证TCP协议的全双工连接能够可靠关闭：当因为IP协议的不可靠性或者是其它网络原因，导致服务端没有收到客户端的ACK报文时，那么服务端就会在超时之后重新发送FIN，如果此时客户端的连接已经关闭处于CLOSED状态，那么重发的FIN就找不到对应的连接了，从而导致连接错乱，所以，客户端发送完最后的ACK不能直接进入CLOSED状态，而要保持TIME_WAIT状态，当再次收到FIN的收，能够保证对方收到ACK，最后正确关闭连接。</li>
<li>保证这次连接的重复数据段从网络中消失：如果客户端发送最后的ACK直接进入CLOSED状态，然后又再向服务端发起一个新连接，这时不能保证新连接的与刚关闭的连接的端口号是不同的，也就是新连接和老连接的端口号可能一样了，那么就可能出现问题：如果前一次的连接某些数据滞留在网络中，这些延迟数据在建立新连接后到达客户端，由于新老连接的端口号和IP都一样，TCP协议就认为延迟数据是属于新连接的，新连接就会接收到“脏数据”，这样就会导致数据包混乱。所以TCP连接需要在TIME_WAIT状态等待2*MSL，才能保证本次连接的所有数据在网络中消失。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>IP</strong>：IP协议规定了所有连接到互联网中的设备都必须拥有自己唯一的“身份号”——IP地址，网络设备间进行信息交互时，必须在数据报文中设定目标设备的IP地址方能将数据准确传输至目标设备。互联网中的一台网络设备可以拥有多个IP地址，但一个IP地址只能对应一台网络设备，即IP地址具有唯一性。</p>
<ul>
<li><p>IP地址的构成： IP地址是一串数字，遵循国际编写规范，共由32位二进制数字0&#x2F;1组成。当以十进制数字表达时，数字IP地址使用点分割十进制表示法，采用格式n.n.n.n，每8位为一组，称为八位元组（每个字段最大值是255）。如192.168.0.0，地址格式为：IP地址&#x3D;网络地址＋主机地址 或IP地址&#x3D;主机地址＋子网地址＋主机地址。地址总容量有2^32&#x3D;4294967296个。而IPv6地址采用128位标识，数量为2的128次方，相当于IPv4地址空间的4次幂。（下文提及的都是IPv4）</p>
<p>为了便于寻址以及层次化构造网络，每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。各种网络的差异很大，有的网络中有很多主机，而有的网络中主机数很少，只需做到在该单位管辖的范围内无重复的主机号即可。把IP地址划分为不同的类别是为了更好地满足不同用户的需求。IP地址根据网络ID的不同分为5种类型，A类地址、B类地址、C类地址、D类地址和E类地址。</p>
</li>
<li><p>子网与子网掩码：子网就是将主机地址的几位用来做网络地址来将网络划分为若干个子网，便于管理的同时还能减少IP的浪费。子网掩码，又叫网络掩码，是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，必须配合IP使用。</p>
<p>子网的出现是基于以下原因：</p>
<ul>
<li><p>节约IP资源：随着互联的发展IPV4地址资源可能会耗尽，如果不划分子网直接将一个C类地址分给一个企业，C类地址可容纳256台主机，但是可能该企业只有20台计算机，这就造成极大浪费。</p>
</li>
<li><p>减少网络流量，优化网络性能：隔离数据在整个网络内广播，提高信息传输速率。</p>
</li>
</ul>
<p>子网掩码的用途：通过子网掩码计算出一台主机所在的子网和其他网络的关系，进行正确的通信（网络地址相同，表明接受方在本网络上，那么可以把数据包直接发送到目标主机，否则就需要路由网关将数据包转发送到目的地）。</p>
</li>
<li><p><strong>网关</strong>（Gateway）：IP地址是以网络号和主机号来表示网络上的主机的，只有在一个网络号下的计算机之间才能“直接”互通（同一网段的子网内的主机之间通信不需要经过网关，发送的是广播报文），子网掩码的作用就是用来判断任意两个IP地址是否属于同一子网络，这时只有在同一子网的计算机才能”直接”互通。不同网络号的计算机要通过网关才能互通，简单来说，网关它就是为了管理不同网段的IP，网关实质上是一个网络通向其他网络的IP地址。网关既可以用于广域网互连，也可以用于局域网互连。</p>
</li>
</ul>
</li>
<li><p><strong>TCP&#x2F;IP网络模型</strong>：TCP&#x2F;IP模型，又叫5层因特网协议栈，有五个层次（也有四个层次的说法），以<strong>自顶向下</strong>的方法，分别是<strong>应用层</strong>、<strong>运输层</strong>、<strong>网络层</strong>、<strong>链路层</strong>、<strong>物理层</strong>： </p>
<ol>
<li><p><strong>应用层</strong>：应用层是网络应用程序及其应用层协议存留的地方（例如HTTP、SMTP、TFTP、FTP、NFS等）。应用层是协议栈与主机上应用程序或进程接口的地方，因此也被称为*<u>处理层</u>*。</p>
<p>TCP&#x2F;IP服务的运行依赖于下面两个要素：</p>
<ul>
<li>守护程序（侦听进程）：处理特定服务的入栈用户请求。</li>
<li>端口地址：用于识别特定的进程和服务。端口地址使用16位数表示（一个主机最多有2^16-1个端口）。在范围0-1024之间的端口地址经常被称为公认端口地址。如：FTP的公认端口为21。</li>
</ul>
</li>
<li><p><strong>运输层</strong>：运输层在应用程序端点之间传送应用层报文。因特网中有两种运输协议，即TCP和UDP，用于运输应用层报文。</p>
</li>
<li><p><strong>网络层</strong>：网络层主要解决不同子网间的通信，负责将称为<strong>数据报</strong>的网络层分组从一台主机移动到另一台主机。以下是几种重要的协议：</p>
<ul>
<li><p>IP协议：在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一个唯一的地址，即IP地址，用于区分两台主机是否同属一个网络，实现寻址功能。</p>
</li>
<li><p>ICMP（网间控制报文协议）：处理基于IP路由和网络行为的消息，提供网络诊断信息。</p>
</li>
<li><p>ARP（地址解析协议）：在特定的电缆网段上将数字IP网络地址转换为媒体访问控制（MAC）地址。</p>
</li>
<li><p>RIP协议(路由信息协议)：RIP实现了不在同一子网的两台主机的数据包发送。以太网会将发送方的数据包转发给本子网的网关进行路由，网关会进行多次转发，最终将该数据包转发到目标IP所在的子网中，然后再通过ARP获取目标机MAC，最终也是通过广播形式将数据包发送给接收方。</p>
</li>
<li><p>RARP（反向地址解析协议）：将MAC地址转换成数字IP地址。</p>
</li>
<li><p>BOOTP（引导协议）：是动态主机配置协议（DHCP）的前导协议，DHCP管理网络IP地址分配和其他IP配置数据，BOOTP支持网络设备从网络上获取引导和配置数据。</p>
</li>
</ul>
</li>
<li><p><strong>链路层</strong>：为了将分组从一个节点移动到路径上的下一个节点，网络层必须依靠链路层的服务。在每一个节点，网络层将数据报下传该链路层，链路层沿着路径将数据报传递到下一个节点，在该下一个节点处，链路层又将数据报上传给网络层。</p>
<p>链路层提供的服务取决于应用于该链路的特定链路层协议。例如，以太网协议规定一组电信号就是一个数据包，一个数据包被称一<strong>帧</strong>。其他协议还有WiFi和电缆接入网的DOCSIS协议，而在链路层运用得最广泛的协议是<strong>点对点协议PPP</strong>。</p>
</li>
<li><p><strong>物理层</strong>：实际最终信号的传输是通过物理层实现的，而物理层通过物理介质传输比特流。物理层的协议是链路相关，并且进一步与物理介质相关，常见的有集线器、中继器、调制解调器、光纤、双绞线，以及无线电波，它决定了电信号（0和1）的传输方式，物理介质的不同决定了电信号的传输带宽、速率、传输距离以及抗干扰性等等。 例如，以太网具有许多物理层协议：关于双绞铜线、关于同轴电缆、关于光纤，等等。在每种场合中，跨越这些链路移动一个比特是以不同的方式进行的。物理层的PDU（协议数据单元）由专门的串行信号模式组成，这些模式对应于数据链路层里的帧的位模式。</p>
</li>
</ol>
</li>
</ul>
<p><strong>HTTP</strong>:HTTP（超文本传输协议，HyperText Transfer Protocol）是Web的<strong>应用层协议</strong>，用于传输超文本（如HTML）。HTTP由两个程序实现：一个客户程序和一个服务器程序。客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话，HTTP定义了这些报文的结构以及客户和服务器进行报文交换的方式。</p>
<ul>
<li><p>HTTP协议基于<strong>请求-响应模型</strong>：HTTP使用<strong>TCP</strong>作为它的支撑运输协议，客户首先发起一个与服务器的TCP连接，然后客户端发送HTTP请求给服务器，服务器处理请求并返回HTTP响应，请求和响应都是由头部（ASCII形式）和主体（类似MIME的格式）组成的。</p>
</li>
<li><p>HTTP的几点<strong>特征</strong>如下：无状态协议（stateless protocol）：</p>
<ul>
<li><p>HTTP协议是无状态的，每个请求都是独立的，服务器不会保存之前请求的状态信息，这就意味着服务器不会在请求之间保持会话状态，每个请求都需要包含所有必要的信息。</p>
</li>
<li><p>非持续连接和持续连接：HTTP既能够使用非持续连接，也能够使用持续连接。在非持续连接中，每一个连接都是短暂的，这使得客户端和服务器都能够快速处理连接，节省了服务器的资源。但是，频繁地打开和关闭连接会增加网络开销和延迟；在高负载情况下，频繁的连接建立和关闭可能会成为性能瓶颈，限制服务器的吞吐量。在持续连接中，允许在单个连接上发送多个HTTP请求&#x2F;响应，减少了连接建立和关闭的开销，降低了延迟，并且通过复用连接，可以减少网络传输时间和资源占用，提高服务器和客户端的性能。但是，长时间保持连接会占用服务器资源，尤其是在高并发或连接数过多的情况下；服务器需要管理连接状态，会增加复杂性。所以，非持续连接适用于短暂的、少量的请求&#x2F;响应场景，适合简单的网页浏览等应用；而持续连接适用于需要频繁通信、大量请求&#x2F;响应的场景，能够提高性能和减少延迟。</p>
</li>
<li><p>状态码：HTTP响应包含一个状态码，指示请求的结果。常见的状态码包括200（请求成功）、301（请求的对象永久转移了）、400（请求不能被服务器理解）、404（未找到）、500（服务器内部错误）和505（服务器不支持该HTTP协议版本）等。</p>
</li>
<li><p>支持多种方法：HTTP定义了一系列请求方法，HTTP请求报文中的方法字段可以取不同的值，包括GET、POST、HEAD、PUT和DELETE，不同的值对应不同的请求方法，不同的方法对应不同的操作，其中GET用于请求资源，POST用于提交数据，HEAD与GET相似，但仅返回头部信息而不返回实际资源，通常用于获取资源的元数据，PUT用于上传新资源或更新现有资源，DELETE用于删除资源。</p>
</li>
<li><p>可扩展性：HTTP协议是可扩展的，允许通过添加新的头部字段、请求方法等来支持新的功能或扩展现有功能。</p>
</li>
</ul>
</li>
<li><p><strong>cookie</strong>：HTTP服务器是无状态的，然而一个Web站点通常希望能够识别用户，可能是因为限制用户的访问或把内容与用户身份联系起来等，为此，HTTP使用cookie对用户进行追踪。</p>
<p>基本的工作原理为：cookie是由服务器发送到客户端并存储在客户端的一小段数据。它通常由Web服务器在HTTP响应头部中的Set-cookie字段中发送，并由客户端的Web浏览器存储，然后，客户端在后续的HTTP请求中通过cookie字段将Cookie发送回服务器。</p>
</li>
<li><p><strong>Web缓存</strong>：Web缓存器（Web cache）是一种用于存储网页内容的技术，旨在提高用户访问网页的速度和降低网络资源的消耗。当用户请求一个网页时，Web缓存器会检查请求的内容是否已经在缓存中。如果缓存中有该内容，Web缓存器会直接返回缓存的内容，从而减少从原始服务器传输数据的需求。</p>
<p>Web缓存分为两种：</p>
<ul>
<li>浏览器缓存：这是客户端的缓存，位于用户的计算机或移动设备上，浏览器会根据HTTP headers（如Expires，Cache-Control等）的指示，将网页资源存储在本地磁盘上。</li>
<li>代理缓存：这种缓存位于网络的边缘，通常由网络服务提供商或内容分发网络（CDN）提供。</li>
</ul>
<p>Web缓存具有减少网络延迟和带宽消耗，降低服务器负载，实现CDN，降低成本，提升用户的体验等优点，但是也存在一些问题，如缓存污染（缓存的内容过时或不一致）、隐私问题和安全风险等。</p>
<p>为了解决缓存污染问题，HTTP协议有一种机制，允许缓存器证实它的对象是最新的，即<strong>条件GET方法</strong>。 </p>
</li>
<li><p><strong>HTTPS</strong>：安全套接层（SSL）和传输层安全（TLS）协议可以确保用户在电子商务活动中的通信安全，HTTPS则是HTTP的安全版，通过在HTTP下加入SSL层来实现安全通信。</p>
</li>
</ul>
</li>
</ol>
<p><strong>FTP</strong>:FTP（文件传输协议，File Transfer Protocol）是一种用于在计算机网络中传输文件的标志网络协议。FTP允许用户通过互联网或局域网访问远程计算机上的文件系统，并且可以在客户端和服务器之间传输文件，支持上传、下载、删除、重命名和列出文件等操作。</p>
<p>FTP的几点特征如下：</p>
<ul>
<li>基于TCP&#x2F;IP：FTP是基于TCP&#x2F;IP协议栈的应用层协议（位于OSI模型的第七层应用层），使用TCP进行可靠的数据传输。</li>
<li>客户端-服务器模型：FTP使用客户端-服务器模型，客户端通过FTP客户端软件与FTP服务器进行通信，服务器存储文件，而客户端通过FTP客户端软件与服务器通信。</li>
<li>双通道传输：FTP使用两个TCP的20号和21号端口进行数据传输，20号端口用于数据传输，传输文件内容，而21号端口用于控制连接，传输命令和控制信息。</li>
<li>被动和主动模式：FTP支持两种数据传输模式，分别是主动模式（Active Mode）和被动模式（Passive Mode）。在主动模式中，FTP客户端会通过随机端口主动打开数据连接，并连接到服务器的20号端口；而在被动模式中，FTP客户端会等待服务器主动打开数据连接。被动模式通常用于防火墙后面或NAT（网络地址转换）环境中的客户端。</li>
<li>非加密：FTP最初是以明文形式传输用户凭据和文件内容的，因此存在安全风险。后来出现了FTPS（FTP Secure，FTP通过SSL&#x2F;TLS协议对数据传输进行加密）和SSH文件传输协议（SFTP）等安全扩展，以提供加密和身份验证机制。</li>
</ul>
<p>FTP被广泛用于在Internet上进行文件传输，尤其是在网站维护、软件发布、数据备份等场景中，而由于安全性方面的限制，使用加密和安全协议的替代方案如FTPS和SFTP也变得越来越流行。</p>
<hr>
<h1 id="题型二（实操篇）"><a href="#题型二（实操篇）" class="headerlink" title="题型二（实操篇）"></a><em>题型二（实操篇）</em></h1><h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><p>2.<strong>编写程序</strong>：一个简单的区块链，写了一些<strong>基础的部分</strong>（such as 区块的基本结构、区块链（用的链表把区块link起来）、哈希算法、检验是否篡改），是根据SHA-256算法写的一个个<strong>类SHA256</strong>的哈希加密（其实就是不知道为什么生成的哈希值就是和SHA256线上网站生成的对不上），由于算力和耗时所以<strong>没有挖矿</strong>过程（并且我也没想好该怎么写），也<strong>没有密钥加密</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Blockchain1.0.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> BYTE; <span class="comment">// 8位</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> WORD;  <span class="comment">// 32位数据，4字节表示一个字</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GETNAME(x) #x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 逻辑函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROTRIGHT(a, b) (((a) &gt;&gt; (b)) | ((a) &lt;&lt; (32 - (b))))         <span class="comment">// 循环右移</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CH(x, y, z) (((x) &amp; (y)) ^ ((~x) &amp; (z)))                    <span class="comment">// Ch(h4,h5,h6)=(h4∧h5)⊕(~h4∧h6)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAJ(x, y, z) (((x) &amp; (y)) ^ ((x) &amp; (z)) ^ ((y) &amp; (z)))      <span class="comment">// Ma(h0,h1,h2)=(h0∧h1)⊕(h0∧h2)⊕(h1∧h2)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EP0(x) (ROTRIGHT(x, 2) ^ ROTRIGHT(x, 13) ^ ROTRIGHT(x, 22)) <span class="comment">// Σ0(x)=S2(x)⊕S13(x)⊕S22(x)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EP1(x) (ROTRIGHT(x, 6) ^ ROTRIGHT(x, 11) ^ ROTRIGHT(x, 25)) <span class="comment">// Σ1(x)=S6(x)⊕S11(x)⊕S25(x)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG0(x) (ROTRIGHT(x, 7) ^ ROTRIGHT(x, 18) ^ ((x) &gt;&gt; 3))     <span class="comment">// σ0(x)=S7(x)⊕S18(x)⊕R3(x)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG1(x) (ROTRIGHT(x, 17) ^ ROTRIGHT(x, 19) ^ ((x) &gt;&gt; 10))   <span class="comment">// σ1(x)=S17(x)⊕S19(x)⊕R10(x)</span></span></span><br><span class="line"><span class="comment">// Ch函数:h4当前位为1则取h5的值,为0则取h6的值</span></span><br><span class="line"><span class="comment">// Ma函数:h0,h2,h3逐位比较,0多取0,1多取1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希算法消息处理中间体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    WORD datalen;</span><br><span class="line">    <span class="type">size_t</span> bitlen;</span><br><span class="line">    WORD state[<span class="number">8</span>]; <span class="comment">// 每一步中产生的8个哈希初值</span></span><br><span class="line">&#125; SHA256_CTX;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区块头</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 版本号Version: v_wjx.1.7.10</span></span><br><span class="line">    BYTE *pre_hash;   <span class="comment">// 前哈希值</span></span><br><span class="line">    <span class="type">time_t</span> timestamp; <span class="comment">// 时间戳</span></span><br><span class="line">    <span class="type">int</span> nonce;        <span class="comment">// 随机数</span></span><br><span class="line">    <span class="comment">// int difficulty;   // 哈希难度值:为减少不必要的运算即运行时间,挖矿过程不在本程序中实现</span></span><br><span class="line">&#125; BlockHeader;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区块体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    BYTE *transaction; <span class="comment">// 交易信息——该区块链的每一个区块只包含一次交易信息</span></span><br><span class="line">    BYTE *Merkle_hash; <span class="comment">// Merkle哈希</span></span><br><span class="line">&#125; BlockBody;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区块</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">    BlockHeader block_header;</span><br><span class="line">    BlockBody block_body;</span><br><span class="line">&#125; Block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区块链</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">blockchain</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Block block;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">blockchain</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Blockchain;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于链表操作</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">link</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Blockchain *head;</span><br><span class="line">&#125; List;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> FLAG = <span class="number">0</span>; <span class="comment">// 用于记录区块链上的区块个数</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> WORD init_h[] = &#123;<span class="number">0x6a09e667</span>, <span class="number">0xbb67ae85</span>, <span class="number">0x3c6ef372</span>, <span class="number">0xa54ff53a</span>,</span><br><span class="line">                       <span class="number">0x510e527f</span>, <span class="number">0x9b05688c</span>, <span class="number">0x1f83d9ab</span>, <span class="number">0x5be0cd19</span>&#125;;</span><br><span class="line"><span class="comment">// 取自于自然数中前8个素数的平方根的小数部分的前32位的8个哈希初值</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> WORD k[] = &#123;<span class="number">0x428a2f98</span>, <span class="number">0x71374491</span>, <span class="number">0xb5c0fbcf</span>, <span class="number">0xe9b5dba5</span>,</span><br><span class="line">                  <span class="number">0x3956c25b</span>, <span class="number">0x59f111f1</span>, <span class="number">0x923f82a4</span>, <span class="number">0xab1c5ed5</span>,</span><br><span class="line">                  <span class="number">0xd807aa98</span>, <span class="number">0x12835b01</span>, <span class="number">0x243185be</span>, <span class="number">0x550c7dc3</span>,</span><br><span class="line">                  <span class="number">0x72be5d74</span>, <span class="number">0x80deb1fe</span>, <span class="number">0x9bdc06a7</span>, <span class="number">0xc19bf174</span>,</span><br><span class="line">                  <span class="number">0xe49b69c1</span>, <span class="number">0xefbe4786</span>, <span class="number">0x0fc19dc6</span>, <span class="number">0x240ca1cc</span>,</span><br><span class="line">                  <span class="number">0x2de92c6f</span>, <span class="number">0x4a7484aa</span>, <span class="number">0x5cb0a9dc</span>, <span class="number">0x76f988da</span>,</span><br><span class="line">                  <span class="number">0x983e5152</span>, <span class="number">0xa831c66d</span>, <span class="number">0xb00327c8</span>, <span class="number">0xbf597fc7</span>,</span><br><span class="line">                  <span class="number">0xc6e00bf3</span>, <span class="number">0xd5a79147</span>, <span class="number">0x06ca6351</span>, <span class="number">0x14292967</span>,</span><br><span class="line">                  <span class="number">0x27b70a85</span>, <span class="number">0x2e1b2138</span>, <span class="number">0x4d2c6dfc</span>, <span class="number">0x53380d13</span>,</span><br><span class="line">                  <span class="number">0x650a7354</span>, <span class="number">0x766a0abb</span>, <span class="number">0x81c2c92e</span>, <span class="number">0x92722c85</span>,</span><br><span class="line">                  <span class="number">0xa2bfe8a1</span>, <span class="number">0xa81a664b</span>, <span class="number">0xc24b8b70</span>, <span class="number">0xc76c51a3</span>,</span><br><span class="line">                  <span class="number">0xd192e819</span>, <span class="number">0xd6990624</span>, <span class="number">0xf40e3585</span>, <span class="number">0x106aa070</span>,</span><br><span class="line">                  <span class="number">0x19a4c116</span>, <span class="number">0x1e376c08</span>, <span class="number">0x2748774c</span>, <span class="number">0x34b0bcb5</span>,</span><br><span class="line">                  <span class="number">0x391c0cb3</span>, <span class="number">0x4ed8aa4a</span>, <span class="number">0x5b9cca4f</span>, <span class="number">0x682e6ff3</span>,</span><br><span class="line">                  <span class="number">0x748f82ee</span>, <span class="number">0x78a5636f</span>, <span class="number">0x84c87814</span>, <span class="number">0x8cc70208</span>,</span><br><span class="line">                  <span class="number">0x90befffa</span>, <span class="number">0xa4506ceb</span>, <span class="number">0xbef9a3f7</span>, <span class="number">0xc67178f2</span>&#125;;</span><br><span class="line"><span class="comment">// 取自于自然数中前64个素数的立方根的小数部分的前32位的64个混淆常数</span></span><br><span class="line"></span><br><span class="line">Block *<span class="title function_">genesis_block</span><span class="params">(Block *genesisblock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_block</span><span class="params">(Block *addblock)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show_block</span><span class="params">(Block *block)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cope_block</span><span class="params">(Block *block)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">chain_blocks</span><span class="params">(List *link, Block *block)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check_blockchain</span><span class="params">(List *link)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check_tran_hash</span><span class="params">(BYTE *hash, BYTE *transaction)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sha256</span><span class="params">(BYTE *hash, <span class="type">const</span> BYTE *data)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sha256_init</span><span class="params">(SHA256_CTX *ctx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sha256_transform</span><span class="params">(SHA256_CTX *ctx, <span class="type">const</span> BYTE *data)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Blockchain1.0.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Blockchain1.0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Block *genesisblock = genesis_block(genesisblock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Root用户已创建创世区块!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nthe hash of %s is %s\r\n&quot;</span>, GETNAME(genesisblock), genesisblock-&gt;block_body.Merkle_hash);</span><br><span class="line">    show_block(genesisblock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建区块链</span></span><br><span class="line">    List link;</span><br><span class="line">    link.head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 将创世区块加入区块链中</span></span><br><span class="line">    chain_blocks(&amp;link, genesisblock);</span><br><span class="line"></span><br><span class="line">    Block *preblock = (Block *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Block));</span><br><span class="line">    Block *newblock = (Block *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Block));</span><br><span class="line">    preblock = genesisblock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当区块链中的区块数目足够大时,需要检测哈希以检测交易数据是否被篡改</span></span><br><span class="line">        <span class="keyword">if</span> (FLAG &gt; <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;区块链中区块的数目已经大于4个,现进行检测区块链的交易数据是否被篡改!&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (check_blockchain(&amp;link))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n一切正常!\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n警告!交易数据被篡改,即将强制关闭区块链!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n是否要创建新的区块?(y/n): &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getchar() != <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;区块链1.0很高兴为你服务,再见!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FLAG++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空输入缓冲区</span></span><br><span class="line">        <span class="type">int</span> clear;</span><br><span class="line">        <span class="keyword">while</span> ((clear = getchar()) != EOF &amp;&amp; clear != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            ; <span class="comment">// 未读到文件结尾前提下，清空换行符前的所有字符</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        newblock-&gt;flag = FLAG;</span><br><span class="line">        newblock-&gt;block_header.pre_hash = preblock-&gt;block_body.Merkle_hash;</span><br><span class="line">        newblock-&gt;block_header.timestamp = time(<span class="literal">NULL</span>);</span><br><span class="line">        srand(time(<span class="literal">NULL</span>) * (newblock-&gt;block_header.timestamp - preblock-&gt;block_header.timestamp));</span><br><span class="line">        newblock-&gt;block_header.nonce = rand() * (rand() % <span class="number">1024</span> + <span class="number">1</span>); <span class="comment">// 随便想的一个随机数算法</span></span><br><span class="line">        init_block(newblock);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入交易信息:&quot;</span>);</span><br><span class="line">        gets_s(newblock-&gt;block_body.transaction, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">        cope_block(newblock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nthe hash of block%d is %s\r\n&quot;</span>, newblock-&gt;flag, newblock-&gt;block_body.Merkle_hash);</span><br><span class="line">        show_block(newblock);</span><br><span class="line"></span><br><span class="line">        chain_blocks(&amp;link, newblock);</span><br><span class="line">        preblock = newblock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_block</span><span class="params">(Block *block)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nblock%d的信息如下:\n版本号: v.wjx.1.0\n前哈希值: %s\n时间戳: %lld\n随机数: %d\n交易信息: %s\nMerkel哈希: %s\n&quot;</span>, block-&gt;flag, block-&gt;block_header.pre_hash, block-&gt;block_header.timestamp, block-&gt;block_header.nonce, block-&gt;block_body.transaction, block-&gt;block_body.Merkle_hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Block *<span class="title function_">genesis_block</span><span class="params">(Block *genesisblock)</span></span><br><span class="line">&#123;</span><br><span class="line">    genesisblock = (Block *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Block));</span><br><span class="line">    genesisblock-&gt;block_header.pre_hash = (BYTE *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BYTE));</span><br><span class="line">    genesisblock-&gt;block_body.Merkle_hash = (BYTE *)<span class="built_in">calloc</span>(<span class="number">64</span>, <span class="keyword">sizeof</span>(BYTE));</span><br><span class="line"></span><br><span class="line">    genesisblock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    genesisblock-&gt;block_header.pre_hash = <span class="string">&quot; &quot;</span>; <span class="comment">// 创世区块的最大特点就是没有前哈希值</span></span><br><span class="line">    genesisblock-&gt;block_header.nonce = <span class="number">0</span>;</span><br><span class="line">    genesisblock-&gt;block_header.timestamp = time(<span class="literal">NULL</span>);</span><br><span class="line">    genesisblock-&gt;block_body.transaction = <span class="string">&quot;区块链1.0奖励创建创世区块的Root用户10比特币!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    sha256(genesisblock-&gt;block_body.Merkle_hash, genesisblock-&gt;block_body.transaction);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> genesisblock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_block</span><span class="params">(Block *addblock)</span></span><br><span class="line">&#123;</span><br><span class="line">    addblock-&gt;block_body.transaction = (BYTE *)<span class="built_in">calloc</span>(<span class="number">64</span>, <span class="keyword">sizeof</span>(BYTE));</span><br><span class="line">    addblock-&gt;block_body.Merkle_hash = (BYTE *)<span class="built_in">calloc</span>(<span class="number">64</span>, <span class="keyword">sizeof</span>(BYTE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cope_block</span><span class="params">(Block *block)</span></span><br><span class="line">&#123;</span><br><span class="line">    sha256(block-&gt;block_body.Merkle_hash, block-&gt;block_body.transaction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chain_blocks</span><span class="params">(List *link, Block *block)</span></span><br><span class="line">&#123;</span><br><span class="line">    Blockchain *p = (Blockchain *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Blockchain));</span><br><span class="line">    p-&gt;block = *block;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    Blockchain *last = link-&gt;head;</span><br><span class="line">    <span class="keyword">if</span> (last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (last-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            last = last-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        last-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        link-&gt;head = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check_blockchain</span><span class="params">(List *link)</span></span><br><span class="line">&#123;</span><br><span class="line">    Blockchain *p, *q, *last;</span><br><span class="line">    <span class="keyword">for</span> (last = link-&gt;head; last; last = last-&gt;next)</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p-&gt;next = last, q = last; p == link-&gt;head;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (check_tran_hash(q-&gt;block.block_body.Merkle_hash, q-&gt;block.block_body.transaction) &amp;&amp; p-&gt;block.block_body.Merkle_hash == q-&gt;block.block_header.pre_hash &amp;&amp; p-&gt;block.flag + <span class="number">1</span> == q-&gt;block.flag)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check_tran_hash</span><span class="params">(BYTE *hash, BYTE *transaction)</span></span><br><span class="line">&#123;</span><br><span class="line">    BYTE *realhash = (BYTE *)<span class="built_in">calloc</span>(<span class="number">64</span>, <span class="keyword">sizeof</span>(BYTE));</span><br><span class="line">    sha256(realhash, transaction);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(hash, realhash) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sha256</span><span class="params">(BYTE *get_hash, <span class="type">const</span> BYTE *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    SHA256_CTX *ctx = (SHA256_CTX *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SHA256_CTX));</span><br><span class="line">    sha256_init(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理</span></span><br><span class="line">    WORD len = <span class="built_in">strlen</span>((<span class="type">char</span> *)data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  STEP1:填充使消息对512取模余448</span></span><br><span class="line">    <span class="type">size_t</span> reallen = (len * <span class="number">8</span>) % <span class="number">512</span> &gt;= <span class="number">448</span> ? ((len * <span class="number">8</span>) / <span class="number">512</span> + <span class="number">2</span>) * <span class="number">64</span> : ((len * <span class="number">8</span>) / <span class="number">512</span> + <span class="number">1</span>) * <span class="number">64</span>;</span><br><span class="line">    BYTE *processsrc = (<span class="type">char</span> *)<span class="built_in">calloc</span>(reallen, <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(processsrc, data, len);</span><br><span class="line">    *(processsrc + len) = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// STEP2:在消息末尾补上代表原始消息长度的64位数据</span></span><br><span class="line">    *((<span class="type">long</span> *)(processsrc + reallen - <span class="number">4</span>)) = len &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    *((<span class="type">long</span> *)(processsrc + reallen - <span class="number">8</span>)) = len &gt;&gt; <span class="number">29</span>;</span><br><span class="line"></span><br><span class="line">    sha256_transform(ctx, processsrc);</span><br><span class="line">    <span class="built_in">free</span>(processsrc);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(get_hash, <span class="string">&quot;%08X%08X%08X%08X%08X%08X%08X%08X&quot;</span>, ctx-&gt;state[<span class="number">0</span>], ctx-&gt;state[<span class="number">1</span>], ctx-&gt;state[<span class="number">2</span>], ctx-&gt;state[<span class="number">3</span>], ctx-&gt;state[<span class="number">4</span>], ctx-&gt;state[<span class="number">5</span>], ctx-&gt;state[<span class="number">6</span>], ctx-&gt;state[<span class="number">7</span>]);</span><br><span class="line">    <span class="comment">// printf(&quot;SHA256: %s\r\n&quot;, ctx-&gt;data);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sha256_init</span><span class="params">(SHA256_CTX *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    ctx-&gt;datalen = <span class="number">0</span>;</span><br><span class="line">    ctx-&gt;bitlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ctx-&gt;state[i] = init_h[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// //对一个长度为512bit的数据块进行操作，将其转换成Hash值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sha256_transform</span><span class="params">(SHA256_CTX *ctx, <span class="type">const</span> BYTE *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    WORD a, b, c, d, e, f, g, h, i, j, t1, t2, m[<span class="number">64</span>]; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息摘要</span></span><br><span class="line">    <span class="comment">// STEP1:分块</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i, j += <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将数据块划分成16个32bit的字，存放到m的前16个字中</span></span><br><span class="line">        m[i] = (data[j] &lt;&lt; <span class="number">24</span>) | (data[j + <span class="number">1</span>] &lt;&lt; <span class="number">16</span>) | (data[j + <span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | (data[j + <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; <span class="number">64</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 其余的字：16-63则按照公式Mt=σ1(M(t-2))+M(t-7)+σ0(M(t-15))+M(t-16)计算</span></span><br><span class="line">        m[i] = SIG1(m[i - <span class="number">2</span>]) + m[i - <span class="number">7</span>] + SIG0(m[i - <span class="number">15</span>]) + m[i - <span class="number">16</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次迭代,映射初值设为8个哈希初值</span></span><br><span class="line">    a = ctx-&gt;state[<span class="number">0</span>];</span><br><span class="line">    b = ctx-&gt;state[<span class="number">1</span>];</span><br><span class="line">    c = ctx-&gt;state[<span class="number">2</span>];</span><br><span class="line">    d = ctx-&gt;state[<span class="number">3</span>];</span><br><span class="line">    e = ctx-&gt;state[<span class="number">4</span>];</span><br><span class="line">    f = ctx-&gt;state[<span class="number">5</span>];</span><br><span class="line">    g = ctx-&gt;state[<span class="number">6</span>];</span><br><span class="line">    h = ctx-&gt;state[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// STEP2:迭代64次</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t1 = h + EP1(e) + CH(e, f, g) + k[i] + m[i];</span><br><span class="line">        t2 = EP0(a) + MAJ(a, b, c);</span><br><span class="line">        h = g;</span><br><span class="line">        g = f;</span><br><span class="line">        f = e;</span><br><span class="line">        e = d + t1;</span><br><span class="line">        d = c;</span><br><span class="line">        c = b;</span><br><span class="line">        b = a;</span><br><span class="line">        a = t1 + t2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 整合hash</span></span><br><span class="line">    ctx-&gt;state[<span class="number">0</span>] += a;</span><br><span class="line">    ctx-&gt;state[<span class="number">1</span>] += b;</span><br><span class="line">    ctx-&gt;state[<span class="number">2</span>] += c;</span><br><span class="line">    ctx-&gt;state[<span class="number">3</span>] += d;</span><br><span class="line">    ctx-&gt;state[<span class="number">4</span>] += e;</span><br><span class="line">    ctx-&gt;state[<span class="number">5</span>] += f;</span><br><span class="line">    ctx-&gt;state[<span class="number">6</span>] += g;</span><br><span class="line">    ctx-&gt;state[<span class="number">7</span>] += h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\wjx27\AppData\Roaming\Typora\typora-user-images\image-20240327185337922.png" alt="image-20240327185337922"></p>
<p><img src="C:\Users\wjx27\AppData\Roaming\Typora\typora-user-images\image-20240327185412480.png" alt="image-20240327185412480"></p>
<hr>
<h2 id="方向选做题——方向1：Hyperledger超级账本（联盟链）"><a href="#方向选做题——方向1：Hyperledger超级账本（联盟链）" class="headerlink" title="方向选做题——方向1：Hyperledger超级账本（联盟链）"></a>方向选做题——<em>方向1：Hyperledger超级账本（联盟链）</em></h2><h3 id="1-go语言基础"><a href="#1-go语言基础" class="headerlink" title="1.go语言基础"></a>1.go语言基础</h3><p>1.go利用hash实现加密一段话:</p>
<blockquote>
<p>只需import “crypto&#x2F;sha256”即可 (雾</p>
</blockquote>
<p>2.go实现RSA算法加密：</p>
<hr>
<h3 id="2-Fabric基础"><a href="#2-Fabric基础" class="headerlink" title="2.Fabric基础"></a>2.Fabric基础</h3><p>1.在Ubuntu22.04上<strong>部署Fabric</strong>1.4.0测试环境：</p>
<p>跟着n多个教程做之后，终于把Ubuntu删了（bushi），重新安装了一个Ubuntu虚拟机，教程说出现这个界面就是成功了？</p>
<p><img src="C:\Users\wjx27\AppData\Roaming\Typora\typora-user-images\image-20240323141803991.png" alt="image-20240323141803991"></p>
<p>2.使用<strong>链码</strong>实现HelloWorld：</p>
<p>模仿网上的示例做的，卡在了启动链码这一步。</p>
<p>helloworld.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/hyperledger/fabric/core/chaincode/shim&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/hyperledger/fabric/protos/peer&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloWorld <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *HelloWorld)</span></span> Init( stub shim.ChaincodeStubInterface) peer.Response &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	args := stub.GetStringArgs()</span><br><span class="line"></span><br><span class="line">	err := stub.PutState(args[<span class="number">0</span>], []<span class="type">byte</span>(args[<span class="number">1</span>]))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		shim.Error(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  shim.Success(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *HelloWorld)</span></span>Invoke(stub shim.ChaincodeStubInterface) peer.Response  &#123;</span><br><span class="line"></span><br><span class="line">	fn, args := stub.GetFunctionAndParameters()</span><br><span class="line">	<span class="keyword">if</span> fn == <span class="string">&quot;set&quot;</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> this.set(stub, args)</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> fn == <span class="string">&quot;get&quot;</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> this.get(stub, args)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> shim.Error(<span class="string">&quot;Invoke func error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *HelloWorld)</span></span>set(stub shim.ChaincodeStubInterface,  args  []<span class="type">string</span>)  peer.Response &#123;</span><br><span class="line">	err := stub.PutState(args[<span class="number">0</span>], []<span class="type">byte</span>(args[<span class="number">1</span>]))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> shim.Success(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *HelloWorld)</span></span>get(stub shim.ChaincodeStubInterface, args []<span class="type">string</span>) peer.Response  &#123;</span><br><span class="line"></span><br><span class="line">	value, err := stub.GetState(args[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> shim.Success(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	err := shim.Start(<span class="built_in">new</span>(HelloWorld))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>helloworld_test.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/hyperledger/fabric/core/chaincode/shim&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkInit</span><span class="params">(t *testing.T, stub *shim.MockStub, args [][]<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">	res := stub.MockInit(<span class="string">&quot;1&quot;</span>, args)</span><br><span class="line">	<span class="keyword">if</span> res.Status != shim.OK &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Init failed&quot;</span>, <span class="type">string</span>(res.Message))</span><br><span class="line">		t.FailNow()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkQuery</span><span class="params">(t *testing.T, stub *shim.MockStub, name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	res := stub.MockInvoke(<span class="string">&quot;1&quot;</span>, [][]<span class="type">byte</span>&#123;[]<span class="type">byte</span>(<span class="string">&quot;get&quot;</span>), []<span class="type">byte</span>(name)&#125;)</span><br><span class="line">	<span class="keyword">if</span> res.Status != shim.OK &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Query&quot;</span>, name, <span class="string">&quot;failed&quot;</span>, <span class="type">string</span>(res.Message))</span><br><span class="line">		t.FailNow()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> res.Payload == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Query&quot;</span>, name, <span class="string">&quot;failed to get value&quot;</span>)</span><br><span class="line">		t.FailNow()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Query value&quot;</span>, name, <span class="string">&quot;was &quot;</span>, <span class="type">string</span>(res.Payload))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkInvoke</span><span class="params">(t *testing.T, stub *shim.MockStub, args [][]<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">	res := stub.MockInvoke(<span class="string">&quot;1&quot;</span>, args)</span><br><span class="line">	<span class="keyword">if</span> res.Status != shim.OK &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Invoke&quot;</span>, args, <span class="string">&quot;failed&quot;</span>, <span class="type">string</span>(res.Message))</span><br><span class="line">		t.FailNow()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_Helloworld</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	hello := <span class="built_in">new</span>(HelloWorld)</span><br><span class="line">	stub := shim.NewMockStub(<span class="string">&quot;hello&quot;</span>, hello)</span><br><span class="line"></span><br><span class="line">	checkInit(t, stub, [][]<span class="type">byte</span>&#123;[]<span class="type">byte</span>(<span class="string">&quot;str&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;helloworld&quot;</span>)&#125;)</span><br><span class="line">	checkQuery(t, stub, <span class="string">&quot;str&quot;</span>)</span><br><span class="line"></span><br><span class="line">	checkInvoke(t, stub, [][]<span class="type">byte</span>&#123;[]<span class="type">byte</span>(<span class="string">&quot;set&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;str&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;helloworld-1111&quot;</span>)&#125;)</span><br><span class="line">	checkQuery(t, stub, <span class="string">&quot;str&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>本地测试成功</p>
<p><img src="C:\Users\wjx27\AppData\Roaming\Typora\typora-user-images\image-20240323223529996.png" alt="image-20240323223529996"></p>
<p><strong>BUT</strong> 启动链码时一直报ERRO 003 context deadline exceeded</p>
<p><img src="C:\Users\wjx27\AppData\Roaming\Typora\typora-user-images\image-20240323152652804.png" alt="image-20240323152652804"></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Fantome</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://username.github.io/project/2024/07/26/BlockChain-Learning-Blog-1/">https://username.github.io/project/2024/07/26/BlockChain-Learning-Blog-1/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/project/tags/BlockChain/"># BlockChain</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/project/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/project/2024/07/26/BlockChain-Learning-Blog-2/">BlockChain Learning Blog 2</a>
            
            
            <a class="next" rel="next" href="/project/2023/10/21/First-Blog/">First Blog</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Fantome | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>
<div class="theme-info">
    <div class="powered-by"></div>
    <span class="post-count">博客全站共{{ totalcount(site) }}字</span>
  </div>  

    </div>
</body>

</html>